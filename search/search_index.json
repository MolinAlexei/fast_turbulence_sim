{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This is the documentation for the code used for creating fast simulations of direct observations of turbulent velocity fields.</p>"},{"location":"intro/","title":"Introduction","text":""},{"location":"notebooks/Create_emissivity/","title":"Create the emissivity table","text":"<p>Here, I describe how I create the emissivity cube used for emission weighting. Beforehand, I need to create a table of flux from which I'll be interpolating. This table is created by using <code>xspec</code>, with the following code :</p> <pre>import xspec as xs\nimport numpy as np\nfrom multiprocessing import Pool\n\nxs.Xset.chatter = 0\n\nxs.Xset.allowPrompting = False\n\ndef getcountsTZ(TZ_vec,\n\tnH = 0.03, #10^22 cm-2\n\tz  = 0.1,  #Cluster redshift\n\tnorm = 1,  #For normalisation\n\tv = 0.,   #Velocity broadening\n\t):\n\t\n\tT, Z = TZ_vec\n\n\txs.AllData.clear()\n\t#Load instrument responses\n\tfs1 = xs.FakeitSettings(response = \"/xifu/home/mola/XIFU_Sims_Turbulence_NewConfig/RMF.rmf\", \n\t                        arf = '/xifu/home/mola/XIFU_Sims_Turbulence_NewConfig/ARF.arf',\n\t                        exposure=1.0)\n\n\t#Define models\n\tm = xs.Model('phabs*bapec')\n\n\t#Define parameters\n\tm.setPars(nH, T, Z, z, v, norm)\n\n\t#Fakeit\n\txs.AllData.fakeit(1, fs1, noWrite = True)\n\n\t#Folded flux\n\tflux = np.sum(np.array(m.folded(1))) #ph/s\n\t#This is the sum of the number of expected number photons received on the detector for the given one second exposure\n\n\treturn flux \n\n\nif __name__ == '__main__' :\n\n\tNpts = 100\n\tT_list = np.linspace(0.1, 10, Npts)\n\tZ_list = np.linspace(0.01, 1, Npts)\n\tmesh = np.meshgrid(T_list, Z_list)\n\tTZ = np.vstack((mesh[0].flatten(), mesh[1].flatten())).T\n\t\n\tp = Pool(32)\n\tflux_table = p.map(getcountsTZ, TZ)\n\tprint(flux_table)\n\n\tnp.save('flux_table_APEC_newXIFU.npy', flux_table)\n</pre> <p>Once I have this table, I use it with the emissivity code to produce an emissivity cube.</p> <p>First, let's do the imports</p> In\u00a0[1]: Copied! <pre>#\u00a0Classics\nimport matplotlib.pyplot as plt\nfrom astropy.io import fits\nimport pickle\nimport jax.numpy as jnp\nimport cmasher as cmr\n\n# Astropy\nimport astropy.units as units\nfrom astropy.cosmology import LambdaCDM\ncosmo = LambdaCDM(H0 = 70, Om0 = 0.3, Ode0 = 0.7)\n\n# fast_turbulence_sim\n# I do this because I don't want to deal with making environments for this code\nimport sys\nsys.path.append('../../src/')\n\nfrom grid import SpatialGrid3D\nfrom emissivity import XrayEmissivity\n\n# haiku\nimport haiku as hk\n</pre> #\u00a0Classics import matplotlib.pyplot as plt from astropy.io import fits import pickle import jax.numpy as jnp import cmasher as cmr  # Astropy import astropy.units as units from astropy.cosmology import LambdaCDM cosmo = LambdaCDM(H0 = 70, Om0 = 0.3, Ode0 = 0.7)  # fast_turbulence_sim # I do this because I don't want to deal with making environments for this code import sys sys.path.append('../../src/')  from grid import SpatialGrid3D from emissivity import XrayEmissivity  # haiku import haiku as hk <p>Define the spatial grid</p> In\u00a0[2]: Copied! <pre># Pixel size \npixsize_m = 317e-6 # 317 um\nfocal_length = 12 # 12 m\npixsize_arcmin = pixsize_m/focal_length * 180 / jnp.pi * 60\npixsize_kpc = pixsize_arcmin * cosmo.kpc_proper_per_arcmin(0.1).value\n\n# Spatial grid\nspatial_grid = SpatialGrid3D(pixsize=pixsize_kpc, \n                             shape=(232,232), \n                             los_factor=5)\nprint('The pixel size in kiloparsecs is {:.2f} kpc'.format(pixsize_kpc))\n</pre> # Pixel size  pixsize_m = 317e-6 # 317 um focal_length = 12 # 12 m pixsize_arcmin = pixsize_m/focal_length * 180 / jnp.pi * 60 pixsize_kpc = pixsize_arcmin * cosmo.kpc_proper_per_arcmin(0.1).value  # Spatial grid spatial_grid = SpatialGrid3D(pixsize=pixsize_kpc,                               shape=(232,232),                               los_factor=5) print('The pixel size in kiloparsecs is {:.2f} kpc'.format(pixsize_kpc))   <pre>The pixel size in kiloparsecs is 10.05 kpc\n</pre> <p>Initialize the emissivty cube function with haiku</p> In\u00a0[3]: Copied! <pre>#\u00a0Path to grid\npath_to_TZ_grid = '../../data/TZ_table/flux_table_APEC_newXIFU.npy'\n\n# Exposure\nexposure = 125e3 \n\n# Redshift to cluster\nz = 0.1\n\n# Pixel size in centimeters, projected at redshift of cluster\npixsize_cm = pixsize_kpc * units.kiloparsec.to(units.cm)\n\n# Filling factor\npixel_pitch = 317\nabsorber_size = 310.7\nfilling_factor = (absorber_size/pixel_pitch)**2\n\nem_func = hk.without_apply_rng(\n                    hk.transform(lambda r: XrayEmissivity(\n                    TZ_grid_to_interp_from = path_to_TZ_grid\n                                                        )(r,\n                                                        exposure = exposure,\n                                                        z = z, \n                                                        pixsize_cm = pixsize_cm,\n                                                        filling_factor = filling_factor\n                                                        )\n                                           \n                                )\n                            )\n\nem_pars = em_func.init(None, 1.)\n</pre> #\u00a0Path to grid path_to_TZ_grid = '../../data/TZ_table/flux_table_APEC_newXIFU.npy'  # Exposure exposure = 125e3   # Redshift to cluster z = 0.1  # Pixel size in centimeters, projected at redshift of cluster pixsize_cm = pixsize_kpc * units.kiloparsec.to(units.cm)  # Filling factor pixel_pitch = 317 absorber_size = 310.7 filling_factor = (absorber_size/pixel_pitch)**2  em_func = hk.without_apply_rng(                     hk.transform(lambda r: XrayEmissivity(                     TZ_grid_to_interp_from = path_to_TZ_grid                                                         )(r,                                                         exposure = exposure,                                                         z = z,                                                          pixsize_cm = pixsize_cm,                                                         filling_factor = filling_factor                                                         )                                                                             )                             )  em_pars = em_func.init(None, 1.) <p>Create the cube (long step, as the cube is rather large)</p> In\u00a0[4]: Copied! <pre>em_cube = em_func.apply(em_pars,\n                   spatial_grid.R)\n</pre> em_cube = em_func.apply(em_pars,                    spatial_grid.R) <p>Show the output map of expected counts, which is the sum of the emissivity along the line of sight :</p> In\u00a0[7]: Copied! <pre>plt.imshow(jnp.log10(jnp.sum(em_cube, axis= -1)), cmr.arctic)\nplt.colorbar(label = 'Expected counts [log10]')\n</pre> plt.imshow(jnp.log10(jnp.sum(em_cube, axis= -1)), cmr.arctic) plt.colorbar(label = 'Expected counts [log10]') Out[7]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x151d7efc35e0&gt;</pre> <p>Warning</p> <p>         This map does not take into account the PSF and vignetting !          So any comparison with the actual count map has to take that          into account as well as a Poisson realization.     </p>"},{"location":"notebooks/Create_emissivity/#create-the-emissivity-table","title":"Create the emissivity table\u00b6","text":""},{"location":"notebooks/Intro_Observables/","title":"Introduction","text":"<p>A few imports :</p> In\u00a0[30]: Copied! <pre>import matplotlib.pyplot as plt\nfrom astropy.io import fits\nimport pickle\nimport jax.numpy as jnp\nimport cmasher as cmr\n\n# I do this because I don't want to deal with making environments for this code\nimport sys\nsys.path.append('../../src/')\nfrom binning import LoadBinning\nfrom structure_function import StructureFunction\n</pre> import matplotlib.pyplot as plt from astropy.io import fits import pickle import jax.numpy as jnp import cmasher as cmr  # I do this because I don't want to deal with making environments for this code import sys sys.path.append('../../src/') from binning import LoadBinning from structure_function import StructureFunction <p>Load the data from the 'output_maps' folder of the Observation5 (that I used as a reference)</p> In\u00a0[34]: Copied! <pre>out_censhift = jnp.array(fits.getdata('../../data/XIFU_Observation5/output_maps/output_bulk_motion.fits'))\nout_broad = jnp.array(fits.getdata('../../data/XIFU_Observation5/output_maps/output_velocity.fits'))\n\n# Actually I also use the input maps\ninp_censhift = jnp.array(fits.getdata('../../data/XIFU_Observation5/input_maps/input_bulk_motion.fits'))\ninp_broad = jnp.array(fits.getdata('../../data/XIFU_Observation5/input_maps/input_stdredshift.fits'))\n</pre> out_censhift = jnp.array(fits.getdata('../../data/XIFU_Observation5/output_maps/output_bulk_motion.fits')) out_broad = jnp.array(fits.getdata('../../data/XIFU_Observation5/output_maps/output_velocity.fits'))  # Actually I also use the input maps inp_censhift = jnp.array(fits.getdata('../../data/XIFU_Observation5/input_maps/input_bulk_motion.fits')) inp_broad = jnp.array(fits.getdata('../../data/XIFU_Observation5/input_maps/input_stdredshift.fits')) <p>One of these maps is the centroid shift that is observed, in a binned map. The second map corresponds to the broadening. The centroid shift is an emission-weighted average value of the speed of the gas along the line of sight, whereas the broadening is an emissio-weighted standard deviation of the speed of the gas along the line of sight.</p> <p>Let's plot them:</p> In\u00a0[16]: Copied! <pre>fig,ax = plt.subplots(1,1, figsize = (6,6))\n\nim =ax.imshow(out_censhift, cmap = cmr.iceburn, vmin = -150, vmax = 150)\nplt.colorbar(im, pad = 0.04, fraction = 0.046, label = 'Centroid shift [km/s]')\n</pre> fig,ax = plt.subplots(1,1, figsize = (6,6))  im =ax.imshow(out_censhift, cmap = cmr.iceburn, vmin = -150, vmax = 150) plt.colorbar(im, pad = 0.04, fraction = 0.046, label = 'Centroid shift [km/s]') Out[16]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x147e7f78bf40&gt;</pre> In\u00a0[26]: Copied! <pre>fig,ax = plt.subplots(1,1, figsize = (6,6))\n\nout_broad = out_broad.at[out_broad &lt; 0.].set(jnp.nan)\n\nim =ax.imshow(out_broad, cmap = cmr.arctic, vmin = 150, vmax = 400)\nplt.colorbar(im, pad = 0.04, fraction = 0.046, label = 'Broadening [km/s]')\n</pre> fig,ax = plt.subplots(1,1, figsize = (6,6))  out_broad = out_broad.at[out_broad &lt; 0.].set(jnp.nan)  im =ax.imshow(out_broad, cmap = cmr.arctic, vmin = 150, vmax = 400) plt.colorbar(im, pad = 0.04, fraction = 0.046, label = 'Broadening [km/s]') Out[26]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x147e7f0d2560&gt;</pre> <p>The actual \"observable\" property of these fields is their second order structure function (SF). Let's plot it</p> In\u00a0[32]: Copied! <pre># Load binning\nbinning = LoadBinning(shape = (232,232),\n                 binning_file = '../../data/XIFU_Observation5/region_files/19p_region_dict.p',\n                 count_map_file = '../../data/XIFU_Observation5/19p_count_image.fits')\n\n# Get values from binning\nX_pixels, Y_pixels, bin_num_pix, nb_bins, xBar_bins, yBar_bins, bin_nb_map = binning()\n\n# Load structure function\nsf = StructureFunction(bins = jnp.geomspace(3,200,20))\n</pre> # Load binning binning = LoadBinning(shape = (232,232),                  binning_file = '../../data/XIFU_Observation5/region_files/19p_region_dict.p',                  count_map_file = '../../data/XIFU_Observation5/19p_count_image.fits')  # Get values from binning X_pixels, Y_pixels, bin_num_pix, nb_bins, xBar_bins, yBar_bins, bin_nb_map = binning()  # Load structure function sf = StructureFunction(bins = jnp.geomspace(3,200,20)) In\u00a0[33]: Copied! <pre>def get_sf_from_map(map_to_convert):\n    \n    #Initialize vector of values per bin\n    vector = jnp.zeros(nb_bins)\n    \n    #Assign values to vector\n    vector = vector.at[bin_num_pix].set(jnp.array(map_to_convert)[X_pixels, Y_pixels])\n    \n    #Structure function\n    dists, sf_vec = sf(vector, xBar_bins, yBar_bins)\n    \n    return dists, sf_vec\n</pre> def get_sf_from_map(map_to_convert):          #Initialize vector of values per bin     vector = jnp.zeros(nb_bins)          #Assign values to vector     vector = vector.at[bin_num_pix].set(jnp.array(map_to_convert)[X_pixels, Y_pixels])          #Structure function     dists, sf_vec = sf(vector, xBar_bins, yBar_bins)          return dists, sf_vec In\u00a0[35]: Copied! <pre>dists, sf_censhift_inp = get_sf_from_map(inp_censhift)\ndists, sf_censhift_out = get_sf_from_map(out_censhift)\n\ndists, sf_broad_inp = get_sf_from_map(inp_broad)\ndists, sf_broad_out = get_sf_from_map(out_broad)\n</pre> dists, sf_censhift_inp = get_sf_from_map(inp_censhift) dists, sf_censhift_out = get_sf_from_map(out_censhift)  dists, sf_broad_inp = get_sf_from_map(inp_broad) dists, sf_broad_out = get_sf_from_map(out_broad) In\u00a0[37]: Copied! <pre>fig, ax = plt.subplots(2,1, figsize = (6,12))\n\nax[0].loglog(dists, sf_censhift_inp, label = 'Input', marker ='.')\nax[0].loglog(dists, sf_censhift_out, label = 'Output', marker ='.')\n#ax[0].loglog(dists, sf_censhift_inp+2*std_diff_censhift**2, label = r'Output + $2\\sigma^2$', marker ='.', color = 'tab:blue', alpha = 0.5, ls = '--')\nax[0].set_xlabel('Separation [pixels]')\nax[0].set_ylabel('Centroid shift SF [km2/s2]')\nax[0].legend()\n\nax[1].loglog(dists, sf_broad_inp, label = 'Input', marker ='.')\nax[1].loglog(dists, sf_broad_out, label = 'Output', marker ='.')\n#ax[1].loglog(dists, sf_broad_inp+2*std_diff_broad**2, label = r'Output + $2\\sigma^2$', marker ='.', color = 'tab:blue', alpha = 0.5, ls = '--')\nax[1].set_xlabel('Separation [pixels]')\nax[1].set_ylabel('Broadening SF [km2/s2]')\nax[1].legend()\n</pre> fig, ax = plt.subplots(2,1, figsize = (6,12))  ax[0].loglog(dists, sf_censhift_inp, label = 'Input', marker ='.') ax[0].loglog(dists, sf_censhift_out, label = 'Output', marker ='.') #ax[0].loglog(dists, sf_censhift_inp+2*std_diff_censhift**2, label = r'Output + $2\\sigma^2$', marker ='.', color = 'tab:blue', alpha = 0.5, ls = '--') ax[0].set_xlabel('Separation [pixels]') ax[0].set_ylabel('Centroid shift SF [km2/s2]') ax[0].legend()  ax[1].loglog(dists, sf_broad_inp, label = 'Input', marker ='.') ax[1].loglog(dists, sf_broad_out, label = 'Output', marker ='.') #ax[1].loglog(dists, sf_broad_inp+2*std_diff_broad**2, label = r'Output + $2\\sigma^2$', marker ='.', color = 'tab:blue', alpha = 0.5, ls = '--') ax[1].set_xlabel('Separation [pixels]') ax[1].set_ylabel('Broadening SF [km2/s2]') ax[1].legend() Out[37]: <pre>&lt;matplotlib.legend.Legend at 0x147e715c9ff0&gt;</pre>"},{"location":"notebooks/Intro_Observables/#introduction","title":"Introduction\u00b6","text":""},{"location":"notebooks/Intro_Observables/#which-observables-do-we-want-to-reproduce-with-the-sim","title":"Which observables do we want to reproduce with the sim\u00b6","text":"<p>This fast simulator is here to emulate the process of observing turbulent speeds within a galaxy cluster with an instrument such as X-IFU. The goal is to produce simulations that would be provided as input to Simulation Based Inference, to produce inference on a \"real\" (realistic) simulation. First, let's have a look at the data as it is output from the realistic simulation.</p>"},{"location":"notebooks/Intro_Observables/#the-output-maps-centroid-shift-and-broadening","title":"The output maps : centroid shift and broadening\u00b6","text":""},{"location":"notebooks/Intro_Observables/#the-structure-function","title":"The structure function\u00b6","text":""},{"location":"notebooks/create_psf/","title":"Creating the PSF with SIXTE","text":"<p>I have struggled to use an anlytical implementation of the PSF as the documentation is sparse and does not seem to really work for some reason. I then resorted to using the PSF produced by SIXTE as output to a photon list of a perfect point source at 1 keV.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom astropy.io import fits\nimport cmasher as cmr\n</pre> import numpy as np import matplotlib.pyplot as plt from astropy.io import fits import cmasher as cmr <p>I create a photon list with all photons at 1 keV and at RA, DEC = 0</p> In\u00a0[3]: Copied! <pre>phlist = fits.open('../../data/ph_list_for_PSF.fits')\n</pre> phlist = fits.open('../../data/ph_list_for_PSF.fits') In\u00a0[8]: Copied! <pre>print('Photon energies [keV] : ',phlist[2].data['ENERGY'][:5])\n</pre> print('Photon energies [keV] : ',phlist[2].data['ENERGY'][:5]) <pre>Photon energies [keV] :  [1. 1. 1. 1. 1.]\n</pre> In\u00a0[11]: Copied! <pre>print('Photon right ascensions [rad] : ',phlist[2].data['RA'][:4])\n</pre> print('Photon right ascensions [rad] : ',phlist[2].data['RA'][:4]) <pre>Photon right ascensions [rad] :  [9.99999997e-07 9.99999997e-07 9.99999997e-07 9.99999997e-07]\n</pre> In\u00a0[12]: Copied! <pre>print('Photon declinations [rad] : ',phlist[2].data['DEC'][:4])\n</pre> print('Photon declinations [rad] : ',phlist[2].data['DEC'][:4]) <pre>Photon declinations [rad] :  [9.99999997e-07 9.99999997e-07 9.99999997e-07 9.99999997e-07]\n</pre> <p>Now use <code>sixte</code> with files defining instrument</p> In\u00a0[21]: Copied! <pre>std_xmlfile = '/xifu/usr/share/sixte/instruments/athena-xifu_2024_11/baseline/xifu_nofilt_infoc.xml'\nsimputfile = '../../data/ph_list_for_PSF.fits'\nexposure = 1e5\neventfile = '../../data/event_list_for_PSF.evt'\n</pre> std_xmlfile = '/xifu/usr/share/sixte/instruments/athena-xifu_2024_11/baseline/xifu_nofilt_infoc.xml' simputfile = '../../data/ph_list_for_PSF.fits' exposure = 1e5 eventfile = '../../data/event_list_for_PSF.evt' In\u00a0[22]: Copied! <pre>import subprocess\n</pre> import subprocess In\u00a0[23]: Copied! <pre>subprocess.run(['sixtesim',\n                  'XMLFile='+std_xmlfile,\n                  'Background=no',\n                  'RA=0.0',\n                  'Dec=0.0',\n                  'Simput='+simputfile, \n                  'Exposure=%g'%exposure,\n                  'clobber=yes',\n                  'EvtFile=%s' % eventfile])\n</pre> subprocess.run(['sixtesim',                   'XMLFile='+std_xmlfile,                   'Background=no',                   'RA=0.0',                   'Dec=0.0',                   'Simput='+simputfile,                    'Exposure=%g'%exposure,                   'clobber=yes',                   'EvtFile=%s' % eventfile]) <pre>initialize ...\nExpected number of pixels in hexagon: 1504\nExpected number of pixels in hexagon: 1504\nSeed = 432048233\nExpected number of pixels in hexagon: 1504\nExpected number of pixels in hexagon: 1504\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\ntry to load all spectra ('../../data/ph_list_for_PSF.fits[PHLIST,1]') into cache ...\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\n***SPII_read_key: Cannot find FILTER keyword - setting it to UNKNOWN\nNumber of pixels after removing overlaps: 1504\n\n\nstart simulation ...\n\n0%   10   20   30   40   50   60   70   80   90   100%\n|----|----|----|----|----|----|----|----|----|----|\n***************************************************\n\n\nstart sky projection ...\n\ncleaning up ...\nfinished successfully!\n\n</pre> Out[23]: <pre>CompletedProcess(args=['sixtesim', 'XMLFile=/xifu/usr/share/sixte/instruments/athena-xifu_2024_11/baseline/xifu_nofilt_infoc.xml', 'Background=no', 'RA=0.0', 'Dec=0.0', 'Simput=../../data/ph_list_for_PSF.fits', 'Exposure=100000', 'clobber=yes', 'EvtFile=../../data/event_list_for_PSF.evt'], returncode=0)</pre> <p>Convert the event list to count map</p> In\u00a0[24]: Copied! <pre># aminconv is a conversion parameter of pixel size in arcmin\n# This calculation is weird but inherited from Edoardo, so for consistency I use the same\npitch=317e-4 #in cm\nNbPix=1504 #as in SIXTE\nfocal=1200. #in cm\nsurf=pitch**2\nField=4*np.arcsin(np.sin(np.arctan2(pitch,2.*focal))**2)\nFieldamin=Field*(180/np.pi*60.)**2\naminconv=np.sqrt(Fieldamin)\n</pre> # aminconv is a conversion parameter of pixel size in arcmin # This calculation is weird but inherited from Edoardo, so for consistency I use the same pitch=317e-4 #in cm NbPix=1504 #as in SIXTE focal=1200. #in cm surf=pitch**2 Field=4*np.arcsin(np.sin(np.arctan2(pitch,2.*focal))**2) Fieldamin=Field*(180/np.pi*60.)**2 aminconv=np.sqrt(Fieldamin) In\u00a0[25]: Copied! <pre>image_file = '../../data/PSF_image_test.fits'\n</pre> image_file = '../../data/PSF_image_test.fits' In\u00a0[26]: Copied! <pre>subprocess.check_call([\"imgev\",\n                            \"EvtFile=\"+eventfile,\n                            \"Image=\"+image_file,\n                            \"NAXIS1=58\",\"NAXIS2=58\",\n                            \"CRVAL1=0.0\",\"CRVAL2=0.0\",\n                           \"CRPIX1=29.\",\"CRPIX2=29.\",\n                           \"CDELT1=-%.15f\" %(aminconv/60.),\n                           \"CDELT2=%.15f\" %(aminconv/60.),\n                           \"CoordinateSystem=0\",\n                           \"Projection=TAN\",\n                           \"CUNIT1=deg\",\n                           \"CUNIT2=deg\"])\n</pre> subprocess.check_call([\"imgev\",                             \"EvtFile=\"+eventfile,                             \"Image=\"+image_file,                             \"NAXIS1=58\",\"NAXIS2=58\",                             \"CRVAL1=0.0\",\"CRVAL2=0.0\",                            \"CRPIX1=29.\",\"CRPIX2=29.\",                            \"CDELT1=-%.15f\" %(aminconv/60.),                            \"CDELT2=%.15f\" %(aminconv/60.),                            \"CoordinateSystem=0\",                            \"Projection=TAN\",                            \"CUNIT1=deg\",                            \"CUNIT2=deg\"]) <pre>initialize ...\nopen event file '../../data/event_list_for_PSF.evt' ...\nGiven file is not a standard Event File, trying to read it as TES Event File...\nopen TES event file '../../data/event_list_for_PSF.evt' ...\nfinished successfully!\n\n</pre> Out[26]: <pre>0</pre> <p>In log10</p> In\u00a0[32]: Copied! <pre>plt.imshow(np.log10(fits.getdata('../../data/PSF_image_test.fits')), cmap = cmr.ember)\nplt.colorbar(label = 'log10 counts')\n</pre> plt.imshow(np.log10(fits.getdata('../../data/PSF_image_test.fits')), cmap = cmr.ember) plt.colorbar(label = 'log10 counts') <pre>/tmp/ipykernel_8195/1135695734.py:1: RuntimeWarning: divide by zero encountered in log10\n  plt.imshow(np.log10(fits.getdata('../../data/PSF_image_test.fits')), cmap = cmr.ember)\n</pre> Out[32]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x154430eae470&gt;</pre> <p>Natural</p> In\u00a0[33]: Copied! <pre>plt.imshow(fits.getdata('../../data/PSF_image_test.fits'), cmap = cmr.ember)\nplt.colorbar(label = 'counts')\n</pre> plt.imshow(fits.getdata('../../data/PSF_image_test.fits'), cmap = cmr.ember) plt.colorbar(label = 'counts') Out[33]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x154430d6f8e0&gt;</pre>"},{"location":"notebooks/create_psf/#creating-the-psf-with-sixte","title":"Creating the PSF with SIXTE\u00b6","text":""},{"location":"notebooks/create_psf/#image-of-the-psf","title":"Image of the PSF\u00b6","text":""},{"location":"notebooks/use_sim/","title":"Reproducing the observation","text":"<p>We start with the imports</p> In\u00a0[38]: Copied! <pre># Classics\nimport matplotlib.pyplot as plt\nfrom astropy.io import fits\nimport jax.numpy as jnp\nimport cmasher as cmr\nimport jax\nimport xarray as xr\n\n# Astropy\nimport astropy.units as units\nfrom astropy.cosmology import LambdaCDM\ncosmo = LambdaCDM(H0 = 70, Om0 = 0.3, Ode0 = 0.7)\n\n# fast_turbulence_sim\n# I do this because I don't want to deal with making environments for this code\nimport sys\nsys.path.append('../../src/')\n\nfrom simulation import rng_key, Simulation\nfrom binning import LoadBinning\nfrom grid import SpatialGrid3D\nfrom structure_function import StructureFunction\nfrom projection import VCubeProjection_v2\n\n# haiku\nimport haiku as hk\n</pre> # Classics import matplotlib.pyplot as plt from astropy.io import fits import jax.numpy as jnp import cmasher as cmr import jax import xarray as xr  # Astropy import astropy.units as units from astropy.cosmology import LambdaCDM cosmo = LambdaCDM(H0 = 70, Om0 = 0.3, Ode0 = 0.7)  # fast_turbulence_sim # I do this because I don't want to deal with making environments for this code import sys sys.path.append('../../src/')  from simulation import rng_key, Simulation from binning import LoadBinning from grid import SpatialGrid3D from structure_function import StructureFunction from projection import VCubeProjection_v2  # haiku import haiku as hk <p>Define the spatial grid</p> In\u00a0[4]: Copied! <pre># Pixel size \npixsize_m = 317e-6 # 317 um\nfocal_length = 12 # 12 m\npixsize_arcmin = pixsize_m/focal_length * 180 / jnp.pi * 60\npixsize_kpc = pixsize_arcmin * cosmo.kpc_proper_per_arcmin(0.1).value\n\n# Spatial grid\nspatial_grid = SpatialGrid3D(pixsize=pixsize_kpc, \n                             shape=(232,232), \n                             los_factor=5)\nprint('The pixel size in kiloparsecs is {:.2f} kpc'.format(pixsize_kpc))\n</pre> # Pixel size  pixsize_m = 317e-6 # 317 um focal_length = 12 # 12 m pixsize_arcmin = pixsize_m/focal_length * 180 / jnp.pi * 60 pixsize_kpc = pixsize_arcmin * cosmo.kpc_proper_per_arcmin(0.1).value  # Spatial grid spatial_grid = SpatialGrid3D(pixsize=pixsize_kpc,                               shape=(232,232),                               los_factor=5) print('The pixel size in kiloparsecs is {:.2f} kpc'.format(pixsize_kpc)) <pre>The pixel size in kiloparsecs is 10.05 kpc\n</pre> <p>Load the emissivity cube used for emission-weighting (see corresponding notebook for the creation of said cube)</p> In\u00a0[5]: Copied! <pre># Emissivity cube\nem = jnp.load('/xifu/home/mola/SBI_Turbulence_newXIFU/data/emissivity_cube_19p_newxifu_novign.npy')\n</pre> # Emissivity cube em = jnp.load('/xifu/home/mola/SBI_Turbulence_newXIFU/data/emissivity_cube_19p_newxifu_novign.npy') <p>Load the binning used for Observation 5 and define SF</p> In\u00a0[6]: Copied! <pre># Load binning\nbinning = LoadBinning(shape = (232,232),\n                 binning_file = '../../data/XIFU_Observation5/region_files/19p_region_dict.p',\n                 count_map_file = '../../data/XIFU_Observation5/19p_count_image.fits')\n\n# Get values from binning\nX_pixels, Y_pixels, bin_num_pix, nb_bins, xBar_bins, yBar_bins, bin_nb_map = binning()\n\n# Load structure function\nsf = StructureFunction(bins = jnp.geomspace(3,200,20))\n</pre> # Load binning binning = LoadBinning(shape = (232,232),                  binning_file = '../../data/XIFU_Observation5/region_files/19p_region_dict.p',                  count_map_file = '../../data/XIFU_Observation5/19p_count_image.fits')  # Get values from binning X_pixels, Y_pixels, bin_num_pix, nb_bins, xBar_bins, yBar_bins, bin_nb_map = binning()  # Load structure function sf = StructureFunction(bins = jnp.geomspace(3,200,20)) <p>Load the fits file defining the instrument PSF and to normalize it to one</p> In\u00a0[14]: Copied! <pre>PSF_kernel = jnp.array(fits.getdata('../../data/XIFU_Observation5/PSF_image.fits'), dtype = 'float64')\nPSF_kernel *= 1/jnp.sum(PSF_kernel)\nPSF_kernel_zero_padded = jnp.pad(PSF_kernel, pad_width = int((232-58)/2), mode = 'edge')\n</pre> PSF_kernel = jnp.array(fits.getdata('../../data/XIFU_Observation5/PSF_image.fits'), dtype = 'float64') PSF_kernel *= 1/jnp.sum(PSF_kernel) PSF_kernel_zero_padded = jnp.pad(PSF_kernel, pad_width = int((232-58)/2), mode = 'edge') <p>Load the measurement error</p> In\u00a0[10]: Copied! <pre>data_mes_err = jnp.load('../../data/XIFU_Observation5/mes_err_stats.npz')\nradial_bins_mes_errors = jnp.array(data_mes_err['radial_bins_mes_errors'], dtype = 'float32')\ncenshift_offsets       = jnp.array(data_mes_err['censhift_offsets'], dtype = 'float32')\ncenshift_errors        = jnp.array(data_mes_err['censhift_errors'], dtype = 'float32')\nbroad_offsets          = jnp.array(data_mes_err['broad_offsets'], dtype = 'float32')\nbroad_errors           = jnp.array(data_mes_err['broad_errors'], dtype = 'float32')\n</pre> data_mes_err = jnp.load('../../data/XIFU_Observation5/mes_err_stats.npz') radial_bins_mes_errors = jnp.array(data_mes_err['radial_bins_mes_errors'], dtype = 'float32') censhift_offsets       = jnp.array(data_mes_err['censhift_offsets'], dtype = 'float32') censhift_errors        = jnp.array(data_mes_err['censhift_errors'], dtype = 'float32') broad_offsets          = jnp.array(data_mes_err['broad_offsets'], dtype = 'float32') broad_errors           = jnp.array(data_mes_err['broad_errors'], dtype = 'float32') In\u00a0[19]: Copied! <pre>#Projection\nprojection = VCubeProjection_v2(binning, em, PSF_kernel_zero_padded)\n\n# Simulation\nsim = hk.transform(lambda : Simulation(spatial_grid,\n                                    sf,\n                                    binning,\n                                    projection,\n                                    radial_bins_mes_errors,\n                                    censhift_offsets,\n                                    censhift_errors,\n                                    broad_offsets,\n                                    broad_errors)()\n                  )\n</pre> #Projection projection = VCubeProjection_v2(binning, em, PSF_kernel_zero_padded)  # Simulation sim = hk.transform(lambda : Simulation(spatial_grid,                                     sf,                                     binning,                                     projection,                                     radial_bins_mes_errors,                                     censhift_offsets,                                     censhift_errors,                                     broad_offsets,                                     broad_errors)()                   ) <p>Now that the simulator is defined, we need to initalize it (this is a procedure required by haiku, which allows parameter inheritance between classes, which is why I use it)</p> In\u00a0[20]: Copied! <pre># Init\npars = sim.init(rng_key())\nfor i in pars['simulation/~/fluctuation_cube/~/kolmogorov_power_spectrum']:\n    print(i, pars['simulation/~/fluctuation_cube/~/kolmogorov_power_spectrum'][i])\n\n# JIT\nsim_jit = jax.jit(sim.apply)\n</pre> # Init pars = sim.init(rng_key()) for i in pars['simulation/~/fluctuation_cube/~/kolmogorov_power_spectrum']:     print(i, pars['simulation/~/fluctuation_cube/~/kolmogorov_power_spectrum'][i])  # JIT sim_jit = jax.jit(sim.apply) <pre>sigma 250.0\nlog_inj 2.4771214\nalpha 3.6666667\n</pre> <p>Check one realization</p> In\u00a0[30]: Copied! <pre>%%time\ndist, sf, sf_std, v_vec, std_vec = sim_jit(pars, rng_key())\n</pre> %%time dist, sf, sf_std, v_vec, std_vec = sim_jit(pars, rng_key()) <pre>CPU times: user 6.52 s, sys: 388 ms, total: 6.91 s\nWall time: 6.91 s\n</pre> <p>Look at the binned velocity field</p> In\u00a0[25]: Copied! <pre>binned_censhift_output = jnp.zeros((232,232))\nbinned_censhift_output = binned_censhift_output.at[X_pixels, Y_pixels].set(v_vec[bin_num_pix])\nfig,ax = plt.subplots(1,1, figsize = (6,6))\n\nim =ax.imshow(binned_censhift_output, cmap = cmr.iceburn, vmin = -150, vmax = 150)\nplt.colorbar(im, pad = 0.04, fraction = 0.046, label = 'Centroid shift [km/s]')\n</pre> binned_censhift_output = jnp.zeros((232,232)) binned_censhift_output = binned_censhift_output.at[X_pixels, Y_pixels].set(v_vec[bin_num_pix]) fig,ax = plt.subplots(1,1, figsize = (6,6))  im =ax.imshow(binned_censhift_output, cmap = cmr.iceburn, vmin = -150, vmax = 150) plt.colorbar(im, pad = 0.04, fraction = 0.046, label = 'Centroid shift [km/s]') Out[25]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x149c78d964a0&gt;</pre> <p>Look at the structure function</p> In\u00a0[29]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (6,4))\n\nax.loglog(dist, sf, marker ='.')\n#ax[0].loglog(dists, sf_censhift_inp+2*std_diff_censhift**2, label = r'Output + $2\\sigma^2$', marker ='.', color = 'tab:blue', alpha = 0.5, ls = '--')\nax.set_xlabel('Separation [pixels]')\nax.set_ylabel('Centroid shift SF [km2/s2]')\n</pre> fig, ax = plt.subplots(1,1, figsize = (6,4))  ax.loglog(dist, sf, marker ='.') #ax[0].loglog(dists, sf_censhift_inp+2*std_diff_censhift**2, label = r'Output + $2\\sigma^2$', marker ='.', color = 'tab:blue', alpha = 0.5, ls = '--') ax.set_xlabel('Separation [pixels]') ax.set_ylabel('Centroid shift SF [km2/s2]')  Out[29]: <pre>Text(0, 0.5, 'Centroid shift SF [km2/s2]')</pre> <p>Check that on average, the simulator outputs something around the observation used as a reference</p> In\u00a0[35]: Copied! <pre>Nsims = 100\nSFs_censhift = jnp.zeros((Nsims,19))\nSFs_broad = jnp.zeros((Nsims,19))\nvecs_censhift = jnp.zeros((Nsims,nb_bins))\nvecs_broad = jnp.zeros((Nsims,nb_bins))\n\n\nfor k in range(Nsims):\n    dist, sf, sf_std, v_vec, std_vec = sim_jit(pars, rng_key())\n    SFs_censhift = SFs_censhift.at[k].set(sf)\n    SFs_broad = SFs_broad.at[k].set(sf_std)\n    vecs_censhift = vecs_censhift.at[k].set(v_vec)\n    vecs_broad = vecs_broad.at[k].set(std_vec)\n</pre> Nsims = 100 SFs_censhift = jnp.zeros((Nsims,19)) SFs_broad = jnp.zeros((Nsims,19)) vecs_censhift = jnp.zeros((Nsims,nb_bins)) vecs_broad = jnp.zeros((Nsims,nb_bins))   for k in range(Nsims):     dist, sf, sf_std, v_vec, std_vec = sim_jit(pars, rng_key())     SFs_censhift = SFs_censhift.at[k].set(sf)     SFs_broad = SFs_broad.at[k].set(sf_std)     vecs_censhift = vecs_censhift.at[k].set(v_vec)     vecs_broad = vecs_broad.at[k].set(std_vec) In\u00a0[39]: Copied! <pre>SFs_real = xr.open_dataset(\"../../data/XIFU_Observation5/outputs_SFs.nc\")\n</pre> SFs_real = xr.open_dataset(\"../../data/XIFU_Observation5/outputs_SFs.nc\") In\u00a0[43]: Copied! <pre>fig, ax = plt.subplots(2,1, figsize = (6,12))\n\nax[0].loglog(dist, jnp.mean(SFs_censhift, axis =0),\n            label = 'Average predicted output SF')\n\nax[0].fill_between(dist, \n                   jnp.percentile(SFs_censhift, 2, axis = 0),\n                   jnp.percentile(SFs_censhift, 98, axis = 0),\n                   alpha = 0.2,\n                   label = '2-98%'\n                  )\n\nax[0].fill_between(dist, \n                   jnp.percentile(SFs_censhift, 15, axis = 0),\n                   jnp.percentile(SFs_censhift, 85, axis = 0),\n                   alpha = 0.5,\n                   color = 'tab:blue',\n                   label = '15-85%')\n\nax[1].loglog(dist, jnp.mean(SFs_broad, axis =0),\n            label = 'Average predicted output SF')\n\nax[1].fill_between(dist, \n                   jnp.percentile(SFs_broad, 2, axis = 0),\n                   jnp.percentile(SFs_broad, 98, axis = 0),\n                   alpha = 0.2,\n                   label = '2-98%')\n\nax[1].fill_between(dist, \n                   jnp.percentile(SFs_broad, 15, axis = 0),\n                   jnp.percentile(SFs_broad, 85, axis = 0),\n                   alpha = 0.5,\n                   color = 'tab:blue',\n                   label = '15-85%')\n\n#ax[0].loglog(dist, sf, label = 'Input ', marker ='.')\n\nax[0].loglog(dist, \n             SFs_real.sel(SF = 'CentroidShift').to_array()[0], \n             label = 'Output SF, Obs5', marker ='.')\n\n#ax[0].loglog(dists_obs2, sf_censhift_inp_obs2, label = 'Input Obs 2', marker ='.')\n#ax[0].loglog(dists, sf_censhift_out, label = 'Output', marker ='.')\n\nax[0].set_xlabel('Separation [pixels]')\nax[0].set_ylabel('Centroid shift SF [km2/s2]')\nax[0].legend()\n#ax[0].set_ylim(2e2, 5e4)\n\nax[1].loglog(dist, \n             SFs_real.sel(SF = 'Broadening').to_array()[0], \n             label = 'Output SF, Obs5', marker ='.')\n#ax[1].loglog(dists, sf_broad_inp_obs2, label = 'Input Obs 2', marker ='.')\nax[1].set_xlabel('Separation [pixels]')\nax[1].set_ylabel('Broadening SF [km2/s2]')\nax[1].legend()\n#ax[1].set_ylim(1e2, 5e3)\n</pre> fig, ax = plt.subplots(2,1, figsize = (6,12))  ax[0].loglog(dist, jnp.mean(SFs_censhift, axis =0),             label = 'Average predicted output SF')  ax[0].fill_between(dist,                     jnp.percentile(SFs_censhift, 2, axis = 0),                    jnp.percentile(SFs_censhift, 98, axis = 0),                    alpha = 0.2,                    label = '2-98%'                   )  ax[0].fill_between(dist,                     jnp.percentile(SFs_censhift, 15, axis = 0),                    jnp.percentile(SFs_censhift, 85, axis = 0),                    alpha = 0.5,                    color = 'tab:blue',                    label = '15-85%')  ax[1].loglog(dist, jnp.mean(SFs_broad, axis =0),             label = 'Average predicted output SF')  ax[1].fill_between(dist,                     jnp.percentile(SFs_broad, 2, axis = 0),                    jnp.percentile(SFs_broad, 98, axis = 0),                    alpha = 0.2,                    label = '2-98%')  ax[1].fill_between(dist,                     jnp.percentile(SFs_broad, 15, axis = 0),                    jnp.percentile(SFs_broad, 85, axis = 0),                    alpha = 0.5,                    color = 'tab:blue',                    label = '15-85%')  #ax[0].loglog(dist, sf, label = 'Input ', marker ='.')  ax[0].loglog(dist,               SFs_real.sel(SF = 'CentroidShift').to_array()[0],               label = 'Output SF, Obs5', marker ='.')  #ax[0].loglog(dists_obs2, sf_censhift_inp_obs2, label = 'Input Obs 2', marker ='.') #ax[0].loglog(dists, sf_censhift_out, label = 'Output', marker ='.')  ax[0].set_xlabel('Separation [pixels]') ax[0].set_ylabel('Centroid shift SF [km2/s2]') ax[0].legend() #ax[0].set_ylim(2e2, 5e4)  ax[1].loglog(dist,               SFs_real.sel(SF = 'Broadening').to_array()[0],               label = 'Output SF, Obs5', marker ='.') #ax[1].loglog(dists, sf_broad_inp_obs2, label = 'Input Obs 2', marker ='.') ax[1].set_xlabel('Separation [pixels]') ax[1].set_ylabel('Broadening SF [km2/s2]') ax[1].legend() #ax[1].set_ylim(1e2, 5e3) Out[43]: <pre>&lt;matplotlib.legend.Legend at 0x149c70f7eec0&gt;</pre>"},{"location":"notebooks/use_sim/#reproducing-the-observation","title":"Reproducing the observation\u00b6","text":"<p>What we want is to have a simulator that is able to reproduce the outputs of Observation 5 with different values of the turbulent power spectrum. We keep the emissivity field, binning and everything else fixed.</p>"},{"location":"notebooks/use_sim/#define-the-simulator","title":"Define the simulator\u00b6","text":""},{"location":"references/abundance/","title":"Abundance","text":""},{"location":"references/abundance/#abundance","title":"<code>abundance</code>","text":"<p>Python module containing models for the abundance profile of the ICM.</p>"},{"location":"references/abundance/#abundance.XCOPAbundance","title":"<code>XCOPAbundance</code>","text":"<p>               Bases: <code>Module</code></p> <p>Universal iron abundance profile as defined in Ghirardini 2018+ in the X-COP cluster sample</p> \\[Fe(x) = 0.21 (x + 0.021)^{-0.48} - 6.54\\times \\exp(- \\frac{(r + 0.0816)^2}{0.0027})\\] Source code in <code>src/abundance.py</code> <pre><code>class XCOPAbundance(hk.Module):\n    r\"\"\"Universal iron abundance profile as defined in Ghirardini 2018+ in the X-COP cluster sample\n\n    $$Fe(x) = 0.21 (x + 0.021)^{-0.48} - 6.54\\times \\exp(- \\frac{(r + 0.0816)^2}{0.0027})$$\n    \"\"\"\n\n    def __init__(self):\n        super(XCOPAbundance, self).__init__()\n\n    def __call__(self, r):\n        \"\"\"\n        Compute the abundance function for a given radius, following Mernier et al 2017.\n\n        Parameters:\n            r (jnp.array): Radius to compute the temperature in kpc\n\n        Returns:\n            (jnp.array): Abundance function evaluated at the given radius\n        \"\"\"\n\n        R500 = 1309. #[kpc]\n        x = r/R500\n        Z = 0.21*(x+0.021)**(-0.48) - 6.54*jnp.exp( - (x+0.0816)**2 / (0.0027) )\n\n        #Clip the values to the [0.1-0.9] range (otherwise the T-Z interpolation does not work.)\n        return Z #jnp.clip(Z, 0.1, 0.9)\n</code></pre>"},{"location":"references/abundance/#abundance.XCOPAbundance.__call__","title":"<code>__call__(r)</code>","text":"<p>Compute the abundance function for a given radius, following Mernier et al 2017.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>array</code> <p>Radius to compute the temperature in kpc</p> required <p>Returns:</p> Type Description <code>array</code> <p>Abundance function evaluated at the given radius</p> Source code in <code>src/abundance.py</code> <pre><code>def __call__(self, r):\n    \"\"\"\n    Compute the abundance function for a given radius, following Mernier et al 2017.\n\n    Parameters:\n        r (jnp.array): Radius to compute the temperature in kpc\n\n    Returns:\n        (jnp.array): Abundance function evaluated at the given radius\n    \"\"\"\n\n    R500 = 1309. #[kpc]\n    x = r/R500\n    Z = 0.21*(x+0.021)**(-0.48) - 6.54*jnp.exp( - (x+0.0816)**2 / (0.0027) )\n\n    #Clip the values to the [0.1-0.9] range (otherwise the T-Z interpolation does not work.)\n    return Z #jnp.clip(Z, 0.1, 0.9)\n</code></pre>"},{"location":"references/binning/","title":"Binning","text":""},{"location":"references/binning/#binning","title":"<code>binning</code>","text":""},{"location":"references/binning/#binning.LoadBinning","title":"<code>LoadBinning</code>","text":"<p>Get the different arrays used for a simulation instance from a pickle  binning as created by xifu cluster sims. The count map is needed for returning the count_weighted barycentre of each bin.</p> Source code in <code>src/binning.py</code> <pre><code>class LoadBinning : \n    \"\"\"\n    Get the different arrays used for a simulation instance from a pickle \n    binning as created by xifu cluster sims. The count map is needed for returning the\n    count_weighted barycentre of each bin.\n    \"\"\"\n\n    def __init__(self,\n                 shape = (360,360),\n                 binning_file = '/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_region_200/region_files/19p_region_dict.p',\n                 count_map_file = '/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_count_image.fits'):\n        \"\"\"\n        Initialize binning\n\n        Parameters:\n            shape (tuple): Shape of the final map to provide (should match the shape from SpatialGrid3D)\n            binning_file (str): Path to pickle file containing binning dict\n            count_map_file (str): Path to count map\n        \"\"\"\n        self.shape = shape\n        self.binning_dict, self.region_image = pickle.load(open(binning_file, 'rb'), encoding=\"bytes\")\n        self.countmap = jnp.array(fits.getdata(count_map_file), dtype = 'float32')\n\n    def __call__(self):\n\n        \"\"\"\n        Create the different quantities used from the binning\n\n        Returns:\n            X_pixels (jnp.array): Array of x coordinate of each pixel on the xifusim images\n            Y_pixels (jnp.array): Array of y coordinate of each pixel on the xifusim images \n            bin_num_pix (jnp.array): Array of the bin number of each pixel\n            nb_bins (int): Number of bins\n            xBar_bins (jnp.array): Arrays of the count-wieghted barycenters, x coordinate\n            yBar_bins (jnp.array): Arrays of the count-wieghted barycenters, y coordinate \n            bin_nb_map (jnp.array):  Map of the bin numbers (mainly used as a sanity check)\n        \"\"\"\n\n        # Initialize empty lists\n        binnum = []\n        X = []\n        Y = []\n        xBar = []\n        yBar = []\n\n        # Iterate on the number of bins\n        for k in range(len(self.binning_dict)-1):\n\n            binnum.extend([k] * len(self.binning_dict[k][0]) )\n            x = self.binning_dict[k][1][0]\n            y = self.binning_dict[k][1][1]\n            X.extend(x)\n            Y.extend(y)\n            #Count weighted average for the barycenter of the bin\n            xBar.append(jnp.average(jnp.array(x), weights = self.countmap[x,y]))\n            yBar.append(jnp.average(jnp.array(y), weights = self.countmap[x,y]))\n\n        # Arrays of x and y coordinate of each pixel on the xifusim images\n        self.X_pixels = jnp.array(X)\n        self.Y_pixels = jnp.array(Y)\n\n        # Array of the bin number of each pixel\n        self.bin_num_pix = jnp.array(binnum)\n\n        # Number of bins\n        self.nb_bins = len(jnp.unique(jnp.array(binnum)))\n\n        # Arrays of the count-wieghted barycenters\n        self.xBar_bins = jnp.array(xBar)\n        self.yBar_bins = jnp.array(yBar)\n\n        # Map of the bin numbers (mainly used as a sanity check)\n        self.bin_nb_map = jnp.zeros(self.shape)\n        self.bin_nb_map = self.bin_nb_map.at[self.X_pixels, self.Y_pixels].set(self.bin_num_pix)\n\n        return self.X_pixels, self.Y_pixels, self.bin_num_pix, self.nb_bins, self.xBar_bins, self.yBar_bins, self.bin_nb_map\n</code></pre>"},{"location":"references/binning/#binning.LoadBinning.__call__","title":"<code>__call__()</code>","text":"<p>Create the different quantities used from the binning</p> <p>Returns:</p> Name Type Description <code>X_pixels</code> <code>array</code> <p>Array of x coordinate of each pixel on the xifusim images</p> <code>Y_pixels</code> <code>array</code> <p>Array of y coordinate of each pixel on the xifusim images </p> <code>bin_num_pix</code> <code>array</code> <p>Array of the bin number of each pixel</p> <code>nb_bins</code> <code>int</code> <p>Number of bins</p> <code>xBar_bins</code> <code>array</code> <p>Arrays of the count-wieghted barycenters, x coordinate</p> <code>yBar_bins</code> <code>array</code> <p>Arrays of the count-wieghted barycenters, y coordinate </p> <code>bin_nb_map</code> <code>array</code> <p>Map of the bin numbers (mainly used as a sanity check)</p> Source code in <code>src/binning.py</code> <pre><code>def __call__(self):\n\n    \"\"\"\n    Create the different quantities used from the binning\n\n    Returns:\n        X_pixels (jnp.array): Array of x coordinate of each pixel on the xifusim images\n        Y_pixels (jnp.array): Array of y coordinate of each pixel on the xifusim images \n        bin_num_pix (jnp.array): Array of the bin number of each pixel\n        nb_bins (int): Number of bins\n        xBar_bins (jnp.array): Arrays of the count-wieghted barycenters, x coordinate\n        yBar_bins (jnp.array): Arrays of the count-wieghted barycenters, y coordinate \n        bin_nb_map (jnp.array):  Map of the bin numbers (mainly used as a sanity check)\n    \"\"\"\n\n    # Initialize empty lists\n    binnum = []\n    X = []\n    Y = []\n    xBar = []\n    yBar = []\n\n    # Iterate on the number of bins\n    for k in range(len(self.binning_dict)-1):\n\n        binnum.extend([k] * len(self.binning_dict[k][0]) )\n        x = self.binning_dict[k][1][0]\n        y = self.binning_dict[k][1][1]\n        X.extend(x)\n        Y.extend(y)\n        #Count weighted average for the barycenter of the bin\n        xBar.append(jnp.average(jnp.array(x), weights = self.countmap[x,y]))\n        yBar.append(jnp.average(jnp.array(y), weights = self.countmap[x,y]))\n\n    # Arrays of x and y coordinate of each pixel on the xifusim images\n    self.X_pixels = jnp.array(X)\n    self.Y_pixels = jnp.array(Y)\n\n    # Array of the bin number of each pixel\n    self.bin_num_pix = jnp.array(binnum)\n\n    # Number of bins\n    self.nb_bins = len(jnp.unique(jnp.array(binnum)))\n\n    # Arrays of the count-wieghted barycenters\n    self.xBar_bins = jnp.array(xBar)\n    self.yBar_bins = jnp.array(yBar)\n\n    # Map of the bin numbers (mainly used as a sanity check)\n    self.bin_nb_map = jnp.zeros(self.shape)\n    self.bin_nb_map = self.bin_nb_map.at[self.X_pixels, self.Y_pixels].set(self.bin_num_pix)\n\n    return self.X_pixels, self.Y_pixels, self.bin_num_pix, self.nb_bins, self.xBar_bins, self.yBar_bins, self.bin_nb_map\n</code></pre>"},{"location":"references/binning/#binning.LoadBinning.__init__","title":"<code>__init__(shape=(360, 360), binning_file='/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_region_200/region_files/19p_region_dict.p', count_map_file='/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_count_image.fits')</code>","text":"<p>Initialize binning</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>Shape of the final map to provide (should match the shape from SpatialGrid3D)</p> <code>(360, 360)</code> <code>binning_file</code> <code>str</code> <p>Path to pickle file containing binning dict</p> <code>'/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_region_200/region_files/19p_region_dict.p'</code> <code>count_map_file</code> <code>str</code> <p>Path to count map</p> <code>'/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_count_image.fits'</code> Source code in <code>src/binning.py</code> <pre><code>def __init__(self,\n             shape = (360,360),\n             binning_file = '/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_region_200/region_files/19p_region_dict.p',\n             count_map_file = '/xifu/home/mola/Turbu_300kpc_mosaics/repeat10_125ks/19p_count_image.fits'):\n    \"\"\"\n    Initialize binning\n\n    Parameters:\n        shape (tuple): Shape of the final map to provide (should match the shape from SpatialGrid3D)\n        binning_file (str): Path to pickle file containing binning dict\n        count_map_file (str): Path to count map\n    \"\"\"\n    self.shape = shape\n    self.binning_dict, self.region_image = pickle.load(open(binning_file, 'rb'), encoding=\"bytes\")\n    self.countmap = jnp.array(fits.getdata(count_map_file), dtype = 'float32')\n</code></pre>"},{"location":"references/cooling/","title":"Cooling","text":""},{"location":"references/cooling/#cooling","title":"<code>cooling</code>","text":"<p>Python module containing the interpolation of the APEC emissivity in temperature and abundance.</p>"},{"location":"references/cooling/#cooling.APECEmissivity","title":"<code>APECEmissivity</code>","text":"<p>               Bases: <code>Module</code></p> <p>Universal temperature profile as defined in Ghirardini 2018+ in the X-COP cluster sample</p> Source code in <code>src/cooling.py</code> <pre><code>class APECEmissivity(hk.Module):\n    \"\"\"\n    Universal temperature profile as defined in Ghirardini 2018+ in the X-COP cluster sample\n    \"\"\"\n\n    def __init__(self, TZ_grid_to_interp_from = '/xifu/home/mola/SBI_Turbulence/data/flux_table_APEC_oldXIFU.npy'):\n        super(APECEmissivity, self).__init__()\n\n        \"\"\"\n        OLD Version \n        #Load APEC flux computed for a regular grid of temperatures and abundances\n        #flux_table = np.load('/xifu/home/mola/SBI_Turbulence/data/flux_table_z0.1.npy')\n        #TZ_table = np.load('/xifu/home/mola/SBI_Turbulence/data/flux_interp_z0.1.npy',allow_pickle=True)\n        #(Z_table, T_table, _,_)= TZ_table\n\n\n        #Sum all photons in spectrum\n        #flux_table_photons = np.sum(flux_table, axis = -1, weights )\n\n        #Interpolating function\n        #self.interp_function  = RegularGridInterpolator((Z_table, T_table), flux_table_photons)\n        \"\"\"\n\n        \"\"\"\n        OLD Version 2 \n\n        Npts = 100\n        flux_table = np.reshape(np.load('data/flux_table_APEC_oldXIFU.npy'), (100,100)).T\n\n        T_table = np.linspace(0.1, 10, Npts)\n        Z_table = np.linspace(0.01, 1, Npts)\n\n        self.interp_function = RegularGridInterpolator((T_table, Z_table), flux_table)\n        \"\"\"\n        self.flux_table = jnp.reshape(jnp.load(TZ_grid_to_interp_from), (100,100)).T\n\n\n    def __call__(self, Z, T):\n        \"\"\"\n        Compute the temperature function for a given radius.\n\n        Parameters:\n            Z (float): Abundance \n\t\t\tT (float) : Temperature (keV)\n        Returns:\n            (float): Interpolated flux in photons, for norm = 1 and exposure = 1s\n        \"\"\"\n\n        ### OLD Version 2 : return self.interp_function((T, Z))\n\n        # JAX Version\n\n        Npts = 100\n        T_table = jnp.linspace(0.1, 10, Npts)\n        Z_table = jnp.linspace(0.01, 1, Npts)\n\n        idxT = jnp.searchsorted(T_table, T, 'right')\n        idxZ = jnp.searchsorted(Z_table, Z, 'right')\n\n        T_coord = (T - T_table[idxT])/(T_table[idxT+1] - T_table[idxT]) + idxT\n        Z_coord = (Z - Z_table[idxZ])/(Z_table[idxZ+1] - Z_table[idxZ]) + idxZ\n\n        coordinates = jnp.array([T_coord, Z_coord])\n\n        interp = jax.scipy.ndimage.map_coordinates(self.flux_table, coordinates, order = 1, cval=0.0)\n\n        return interp\n</code></pre>"},{"location":"references/cooling/#cooling.APECEmissivity.__call__","title":"<code>__call__(Z, T)</code>","text":"<p>Compute the temperature function for a given radius.</p> <p>Parameters:</p> Name Type Description Default <code>Z</code> <code>float</code> <p>Abundance          T (float) : Temperature (keV)</p> required <p>Returns:     (float): Interpolated flux in photons, for norm = 1 and exposure = 1s</p> Source code in <code>src/cooling.py</code> <pre><code>    def __call__(self, Z, T):\n        \"\"\"\n        Compute the temperature function for a given radius.\n\n        Parameters:\n            Z (float): Abundance \n\t\t\tT (float) : Temperature (keV)\n        Returns:\n            (float): Interpolated flux in photons, for norm = 1 and exposure = 1s\n        \"\"\"\n\n        ### OLD Version 2 : return self.interp_function((T, Z))\n\n        # JAX Version\n\n        Npts = 100\n        T_table = jnp.linspace(0.1, 10, Npts)\n        Z_table = jnp.linspace(0.01, 1, Npts)\n\n        idxT = jnp.searchsorted(T_table, T, 'right')\n        idxZ = jnp.searchsorted(Z_table, Z, 'right')\n\n        T_coord = (T - T_table[idxT])/(T_table[idxT+1] - T_table[idxT]) + idxT\n        Z_coord = (Z - Z_table[idxZ])/(Z_table[idxZ+1] - Z_table[idxZ]) + idxZ\n\n        coordinates = jnp.array([T_coord, Z_coord])\n\n        interp = jax.scipy.ndimage.map_coordinates(self.flux_table, coordinates, order = 1, cval=0.0)\n\n        return interp\n</code></pre>"},{"location":"references/cube/","title":"Cube","text":""},{"location":"references/cube/#cube","title":"<code>cube</code>","text":""},{"location":"references/cube/#cube.EmissivityCube","title":"<code>EmissivityCube</code>","text":"<p>               Bases: <code>Module</code></p> <p>Generate an emissivity cube</p> Source code in <code>src/cube.py</code> <pre><code>class EmissivityCube(hk.Module):\n    \"\"\"\n    Generate an emissivity cube\n    \"\"\"\n\n    def __init__(self, spatial_grid, exposure = 125e3):\n        \"\"\"\n        Initialize\n\n        Parameters:\n            spatial_grid (class): 3D Spatial grid\n            exposure (float): Exposure time in seconds\n\n        \"\"\" \n        super(EmissivityCube, self).__init__()\n        self.power_spectrum = KolmogorovPowerSpectrum()\n        self.spatial_grid = spatial_grid\n        self.exposure = exposure #exposure in seconds\n        pixsize_cm = self.spatial_grid.pixsize * u.kiloparsec.to(u.cm)\n\n        model = XrayEmissivity()\n        self.lam = model(self.spatial_grid.R) * pixsize_cm**3 * self.exposure\n\n\n\n    def __call__(self):\n        \"\"\"\n        Returns:\n            field_spatial (jnp.array): Random realization of emissivity cube\n\n        \"\"\"\n\n        key = hk.next_rng_key()\n\n\n        field_spatial = np.random.poisson(\n                                       lam  = self.lam, \n                                       size = self.spatial_grid.shape)\n        return field_spatial\n</code></pre>"},{"location":"references/cube/#cube.EmissivityCube.__call__","title":"<code>__call__()</code>","text":"<p>Returns:</p> Name Type Description <code>field_spatial</code> <code>array</code> <p>Random realization of emissivity cube</p> Source code in <code>src/cube.py</code> <pre><code>def __call__(self):\n    \"\"\"\n    Returns:\n        field_spatial (jnp.array): Random realization of emissivity cube\n\n    \"\"\"\n\n    key = hk.next_rng_key()\n\n\n    field_spatial = np.random.poisson(\n                                   lam  = self.lam, \n                                   size = self.spatial_grid.shape)\n    return field_spatial\n</code></pre>"},{"location":"references/cube/#cube.EmissivityCube.__init__","title":"<code>__init__(spatial_grid, exposure=125000.0)</code>","text":"<p>Initialize</p> <p>Parameters:</p> Name Type Description Default <code>spatial_grid</code> <code>class</code> <p>3D Spatial grid</p> required <code>exposure</code> <code>float</code> <p>Exposure time in seconds</p> <code>125000.0</code> Source code in <code>src/cube.py</code> <pre><code>def __init__(self, spatial_grid, exposure = 125e3):\n    \"\"\"\n    Initialize\n\n    Parameters:\n        spatial_grid (class): 3D Spatial grid\n        exposure (float): Exposure time in seconds\n\n    \"\"\" \n    super(EmissivityCube, self).__init__()\n    self.power_spectrum = KolmogorovPowerSpectrum()\n    self.spatial_grid = spatial_grid\n    self.exposure = exposure #exposure in seconds\n    pixsize_cm = self.spatial_grid.pixsize * u.kiloparsec.to(u.cm)\n\n    model = XrayEmissivity()\n    self.lam = model(self.spatial_grid.R) * pixsize_cm**3 * self.exposure\n</code></pre>"},{"location":"references/cube/#cube.FluctuationCube","title":"<code>FluctuationCube</code>","text":"<p>               Bases: <code>Module</code></p> <p>Generate a fluctuation cube as seen from https://garrettgoon.com/gaussian-fields/</p> Source code in <code>src/cube.py</code> <pre><code>class FluctuationCube(hk.Module):\n    \"\"\"\n    Generate a fluctuation cube as seen from https://garrettgoon.com/gaussian-fields/\n    \"\"\"\n\n\n    def __init__(self, spatial_grid):\n        \"\"\"\n        Initialize. The power spectrum is implicitly defined from the Kolmogorov power spectrum\n\n        Parameters:\n            spatial_grid (class): 3D Spatial grid\n            exposure (float): Exposure time in seconds\n\n        \"\"\" \n\n        super(FluctuationCube, self).__init__()\n        self.power_spectrum = KolmogorovPowerSpectrum()\n        self.spatial_grid = spatial_grid\n        self.fourier_grid = FourierGrid3D(self.spatial_grid)\n        self.K = self.fourier_grid.K.astype(np.float64)\n\n    def __call__(self):\n        \"\"\"\n        Returns:\n            field_spatial (jnp.array): Random realization of GRF\n\n        \"\"\"\n\n        key = hk.next_rng_key()\n\n        #Dont mind the rfft, it is here to gain memory\n        field_spatial = random.normal(key, shape=self.spatial_grid.shape)\n        field_fourier = fft.rfftn(field_spatial)*jnp.sqrt(self.power_spectrum(self.K)/self.spatial_grid.pixsize**3)\n        field_spatial = fft.irfftn(field_fourier, s=self.spatial_grid.shape)\n\n        return field_spatial\n</code></pre>"},{"location":"references/cube/#cube.FluctuationCube.__call__","title":"<code>__call__()</code>","text":"<p>Returns:</p> Name Type Description <code>field_spatial</code> <code>array</code> <p>Random realization of GRF</p> Source code in <code>src/cube.py</code> <pre><code>def __call__(self):\n    \"\"\"\n    Returns:\n        field_spatial (jnp.array): Random realization of GRF\n\n    \"\"\"\n\n    key = hk.next_rng_key()\n\n    #Dont mind the rfft, it is here to gain memory\n    field_spatial = random.normal(key, shape=self.spatial_grid.shape)\n    field_fourier = fft.rfftn(field_spatial)*jnp.sqrt(self.power_spectrum(self.K)/self.spatial_grid.pixsize**3)\n    field_spatial = fft.irfftn(field_fourier, s=self.spatial_grid.shape)\n\n    return field_spatial\n</code></pre>"},{"location":"references/cube/#cube.FluctuationCube.__init__","title":"<code>__init__(spatial_grid)</code>","text":"<p>Initialize. The power spectrum is implicitly defined from the Kolmogorov power spectrum</p> <p>Parameters:</p> Name Type Description Default <code>spatial_grid</code> <code>class</code> <p>3D Spatial grid</p> required <code>exposure</code> <code>float</code> <p>Exposure time in seconds</p> required Source code in <code>src/cube.py</code> <pre><code>def __init__(self, spatial_grid):\n    \"\"\"\n    Initialize. The power spectrum is implicitly defined from the Kolmogorov power spectrum\n\n    Parameters:\n        spatial_grid (class): 3D Spatial grid\n        exposure (float): Exposure time in seconds\n\n    \"\"\" \n\n    super(FluctuationCube, self).__init__()\n    self.power_spectrum = KolmogorovPowerSpectrum()\n    self.spatial_grid = spatial_grid\n    self.fourier_grid = FourierGrid3D(self.spatial_grid)\n    self.K = self.fourier_grid.K.astype(np.float64)\n</code></pre>"},{"location":"references/density/","title":"Density","text":""},{"location":"references/density/#density","title":"<code>density</code>","text":""},{"location":"references/density/#density.VikhlininModel","title":"<code>VikhlininModel</code>","text":"<p>               Bases: <code>Module</code></p> <p>Density model which use a modified Vikhlinin functional form, with gamma fixed to 3. See Ghirardini et al. 2019</p> Source code in <code>src/density.py</code> <pre><code>class VikhlininModel(hk.Module):\n    \"\"\"\n    Density model which use a modified Vikhlinin functional form, with gamma fixed to 3.\n    See Ghirardini et al. 2019\n\n    \"\"\"\n\n    def __init__(self):\n        super(VikhlininModel, self).__init__()\n\n    def __call__(self, r):\n        r\"\"\"Compute the density function for a given radius.\n\n        $$n_e^2(x)= n_0^2 \\frac{(\\frac{x}{r_c})^{-\\alpha}}{(1 + (\\frac{x}{r_c})^2)^{3\\beta -\\alpha /2}} \\frac{1}{(1 + (\\frac{x}{r_s})^{\\gamma})^{\\frac{\\epsilon}{\\gamma}}}$$\n\n        Parameters:\n            r (jnp.array): Radius to compute the density function in R500 units\n\n        Returns:\n            (jnp.array): Density function evaluated at the given radius in cm$^{-6}$\n        \"\"\"\n\n        n0 = hk.get_parameter(\"n0\", [], init=Constant(jnp.exp(-4.9)))\n        r_c = hk.get_parameter(\"r_c\", [], init=Constant(jnp.exp(-2.7))) \n\n\n        R500 = 1309. #[kpc]\n        x = r/R500\n        gamma = 3\n        r_s = jnp.exp(-0.51)\n        alpha = 0.7\n        beta = 0.39\n        eps = 2.6\n\n        emiss = n0**2 * (x/r_c)**-alpha / (1 + (x/r_c)**2 )**(3*beta - alpha/2) / (1 + (x/r_s)**gamma)**(eps/gamma)\n        #Cut emission at 5 R500\n        return jnp.clip(emiss * jnp.heaviside(5. - x, 0), 0, 0.05**2)\n</code></pre>"},{"location":"references/density/#density.VikhlininModel.__call__","title":"<code>__call__(r)</code>","text":"<p>Compute the density function for a given radius.</p> \\[n_e^2(x)= n_0^2 \\frac{(\\frac{x}{r_c})^{-\\alpha}}{(1 + (\\frac{x}{r_c})^2)^{3\\beta -\\alpha /2}} \\frac{1}{(1 + (\\frac{x}{r_s})^{\\gamma})^{\\frac{\\epsilon}{\\gamma}}}\\] <p>Parameters:</p> Name Type Description Default <code>r</code> <code>array</code> <p>Radius to compute the density function in R500 units</p> required <p>Returns:</p> Type Description <code>array</code> <p>Density function evaluated at the given radius in cm\\(^{-6}\\)</p> Source code in <code>src/density.py</code> <pre><code>def __call__(self, r):\n    r\"\"\"Compute the density function for a given radius.\n\n    $$n_e^2(x)= n_0^2 \\frac{(\\frac{x}{r_c})^{-\\alpha}}{(1 + (\\frac{x}{r_c})^2)^{3\\beta -\\alpha /2}} \\frac{1}{(1 + (\\frac{x}{r_s})^{\\gamma})^{\\frac{\\epsilon}{\\gamma}}}$$\n\n    Parameters:\n        r (jnp.array): Radius to compute the density function in R500 units\n\n    Returns:\n        (jnp.array): Density function evaluated at the given radius in cm$^{-6}$\n    \"\"\"\n\n    n0 = hk.get_parameter(\"n0\", [], init=Constant(jnp.exp(-4.9)))\n    r_c = hk.get_parameter(\"r_c\", [], init=Constant(jnp.exp(-2.7))) \n\n\n    R500 = 1309. #[kpc]\n    x = r/R500\n    gamma = 3\n    r_s = jnp.exp(-0.51)\n    alpha = 0.7\n    beta = 0.39\n    eps = 2.6\n\n    emiss = n0**2 * (x/r_c)**-alpha / (1 + (x/r_c)**2 )**(3*beta - alpha/2) / (1 + (x/r_s)**gamma)**(eps/gamma)\n    #Cut emission at 5 R500\n    return jnp.clip(emiss * jnp.heaviside(5. - x, 0), 0, 0.05**2)\n</code></pre>"},{"location":"references/emissivity/","title":"Emissivity","text":""},{"location":"references/emissivity/#emissivity","title":"<code>emissivity</code>","text":""},{"location":"references/emissivity/#emissivity.XrayEmissivity","title":"<code>XrayEmissivity</code>","text":"<p>               Bases: <code>Module</code></p> <p>3D Xray emissivity build with temperature, cooling function, density model. It depends on the redshift of the cluster, since the cooling function is precomputed using XSPEC. The default models are the ones used in the papers i.e. Vikhlinin for density, Ghirardini for temperature and the interpolated cooling function.</p> Source code in <code>src/emissivity.py</code> <pre><code>class XrayEmissivity(hk.Module):\n    \"\"\"\n    3D Xray emissivity build with temperature, cooling function, density model.\n    It depends on the redshift of the cluster, since the cooling function is precomputed using XSPEC.\n    The default models are the ones used in the papers i.e. Vikhlinin for density, Ghirardini for temperature\n    and the interpolated cooling function.\n    \"\"\"\n    def __init__(self, TZ_grid_to_interp_from = '/xifu/home/mola/SBI_Turbulence/data/flux_table_APEC_oldXIFU.npy'):\n        super(XrayEmissivity, self).__init__()\n        self.squared_density = VikhlininModel()\n        self.temperature = GhirardiniModel()\n        self.abundance = XCOPAbundance()\n        self.cooling_function = APECEmissivity(TZ_grid_to_interp_from = TZ_grid_to_interp_from)\n        self.cosmo = LambdaCDM(H0 = 70, Om0 = 0.3, Ode0= 0.7)\n\n\n    def __call__(self, r,\n                exposure = 125e3, \n                z = 0.1, \n                pixsize_cm = 1., \n                filling_factor= (271/275)**2):\n        \"\"\"\n        Compute the emissivity at a given radius, including $N_H$ absorption.\n\n        Parameters:\n            r (jnp.array): radius in units of $R_{500}$\n            z (float): Redshift of the cluster\n            pixsize_cm (float) : Projected of the pixel in the cluster, in centimeters\n            filling_factor (float) : Filling factor of the array (absorber size / pixel pitch)\n        \"\"\"\n\n        angular_distance = self.cosmo.angular_diameter_distance(z).value * u.megaparsec.to(u.cm) #cm\n        norm = self.squared_density(r) * 1e-14 / (4 *jnp.pi* (angular_distance*(1+z))**2 ) / 1.2\n\n        factor = filling_factor * exposure * pixsize_cm**3\n\n        return self.cooling_function(self.abundance(r), self.temperature(r)) * norm * factor\n</code></pre>"},{"location":"references/emissivity/#emissivity.XrayEmissivity.__call__","title":"<code>__call__(r, exposure=125000.0, z=0.1, pixsize_cm=1.0, filling_factor=271 / 275 ** 2)</code>","text":"<p>Compute the emissivity at a given radius, including \\(N_H\\) absorption.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>array</code> <p>radius in units of \\(R_{500}\\)</p> required <code>z</code> <code>float</code> <p>Redshift of the cluster</p> <code>0.1</code> <code>pixsize_cm</code> <code>float) </code> <p>Projected of the pixel in the cluster, in centimeters</p> <code>1.0</code> <code>filling_factor</code> <code>float) </code> <p>Filling factor of the array (absorber size / pixel pitch)</p> <code>271 / 275 ** 2</code> Source code in <code>src/emissivity.py</code> <pre><code>def __call__(self, r,\n            exposure = 125e3, \n            z = 0.1, \n            pixsize_cm = 1., \n            filling_factor= (271/275)**2):\n    \"\"\"\n    Compute the emissivity at a given radius, including $N_H$ absorption.\n\n    Parameters:\n        r (jnp.array): radius in units of $R_{500}$\n        z (float): Redshift of the cluster\n        pixsize_cm (float) : Projected of the pixel in the cluster, in centimeters\n        filling_factor (float) : Filling factor of the array (absorber size / pixel pitch)\n    \"\"\"\n\n    angular_distance = self.cosmo.angular_diameter_distance(z).value * u.megaparsec.to(u.cm) #cm\n    norm = self.squared_density(r) * 1e-14 / (4 *jnp.pi* (angular_distance*(1+z))**2 ) / 1.2\n\n    factor = filling_factor * exposure * pixsize_cm**3\n\n    return self.cooling_function(self.abundance(r), self.temperature(r)) * norm * factor\n</code></pre>"},{"location":"references/grid/","title":"Grid","text":""},{"location":"references/grid/#grid","title":"<code>grid</code>","text":""},{"location":"references/grid/#grid.FourierGrid3D","title":"<code>FourierGrid3D</code>","text":"Source code in <code>src/grid.py</code> <pre><code>class FourierGrid3D:\n\n    def __init__(self, spatial_grid):\n        \"\"\"\n        Define 3D Fourier grid from spatial grid\n\n        Parameters:\n            spatial_grid (class): 3D spatial grid \n\n        \"\"\"\n\n        self.kx = fft.fftfreq(len(spatial_grid.x), d=spatial_grid.x[1] - spatial_grid.x[0])\n        self.ky = fft.fftfreq(len(spatial_grid.y), d=spatial_grid.y[1] - spatial_grid.y[0])\n        self.kz = fft.rfftfreq(len(spatial_grid.z), d=spatial_grid.z[1] - spatial_grid.z[0])\n        KX, KY, KZ = jnp.meshgrid(self.kx, self.ky, self.kz, indexing='ij', sparse=True)\n        self.K = jnp.sqrt(KX ** 2 + KY ** 2 + KZ ** 2)\n\n        self.shape = self.K.shape\n</code></pre>"},{"location":"references/grid/#grid.FourierGrid3D.__init__","title":"<code>__init__(spatial_grid)</code>","text":"<p>Define 3D Fourier grid from spatial grid</p> <p>Parameters:</p> Name Type Description Default <code>spatial_grid</code> <code>class</code> <p>3D spatial grid</p> required Source code in <code>src/grid.py</code> <pre><code>def __init__(self, spatial_grid):\n    \"\"\"\n    Define 3D Fourier grid from spatial grid\n\n    Parameters:\n        spatial_grid (class): 3D spatial grid \n\n    \"\"\"\n\n    self.kx = fft.fftfreq(len(spatial_grid.x), d=spatial_grid.x[1] - spatial_grid.x[0])\n    self.ky = fft.fftfreq(len(spatial_grid.y), d=spatial_grid.y[1] - spatial_grid.y[0])\n    self.kz = fft.rfftfreq(len(spatial_grid.z), d=spatial_grid.z[1] - spatial_grid.z[0])\n    KX, KY, KZ = jnp.meshgrid(self.kx, self.ky, self.kz, indexing='ij', sparse=True)\n    self.K = jnp.sqrt(KX ** 2 + KY ** 2 + KZ ** 2)\n\n    self.shape = self.K.shape\n</code></pre>"},{"location":"references/grid/#grid.SpatialGrid3D","title":"<code>SpatialGrid3D</code>","text":"Source code in <code>src/grid.py</code> <pre><code>class SpatialGrid3D:\n\n    def __init__(self, pixsize=8.71, shape=(58, 58), los_factor=5,\n                    x_off = 0, y_off = 0, z_off = 0):\n        \"\"\"\n        Define 3D spatial grid\n\n        Parameters:\n            pixsize (float): Projected pixel size in kiloparsecs\n            shape (tuple): Size of grid on the field of view (Nx,Ny)\n            los_factor (int): Factor by which the z-axis is multiplied (Nz = los_factor * Nx) \n            x_off (int) : Offset along x, in pixels\n            y_off (int) : Offset along x, in pixels\n            z_off (int) : Offset along x, in pixels\n\n        \"\"\"\n\n\n        self.pixsize = pixsize\n\n        x_size, y_size = shape\n        z_size = int(shape[0]*los_factor)\n\n        self.x = jnp.linspace(self.pixsize * (-(x_size - 1)/2 + x_off), self.pixsize * ((x_size - 1)/2 + x_off), x_size) + pixsize/2\n        self.y = jnp.linspace(self.pixsize * (-(y_size - 1)/2 + y_off), self.pixsize * ((y_size - 1)/2 + y_off), y_size) + pixsize/2\n        self.z = jnp.linspace(self.pixsize * (-(z_size - 1)/2 + z_off), self.pixsize * ((z_size - 1)/2 + z_off), z_size)\n        self.X, self.Y, self.Z = jnp.meshgrid(self.x, self.y, self.z, indexing='ij', sparse=True)\n        self.y_i, self.x_i = jnp.indices(shape)\n        self.R = jnp.sqrt(self.X**2 + self.Y**2 + self.Z**2)\n        self.shape = (x_size, y_size, z_size)\n        self.volume = np.prod(self.shape)*pixsize**3\n</code></pre>"},{"location":"references/grid/#grid.SpatialGrid3D.__init__","title":"<code>__init__(pixsize=8.71, shape=(58, 58), los_factor=5, x_off=0, y_off=0, z_off=0)</code>","text":"<p>Define 3D spatial grid</p> <p>Parameters:</p> Name Type Description Default <code>pixsize</code> <code>float</code> <p>Projected pixel size in kiloparsecs</p> <code>8.71</code> <code>shape</code> <code>tuple</code> <p>Size of grid on the field of view (Nx,Ny)</p> <code>(58, 58)</code> <code>los_factor</code> <code>int</code> <p>Factor by which the z-axis is multiplied (Nz = los_factor * Nx) </p> <code>5</code> <code>x_off</code> <code>int) </code> <p>Offset along x, in pixels</p> <code>0</code> <code>y_off</code> <code>int) </code> <p>Offset along x, in pixels</p> <code>0</code> <code>z_off</code> <code>int) </code> <p>Offset along x, in pixels</p> <code>0</code> Source code in <code>src/grid.py</code> <pre><code>def __init__(self, pixsize=8.71, shape=(58, 58), los_factor=5,\n                x_off = 0, y_off = 0, z_off = 0):\n    \"\"\"\n    Define 3D spatial grid\n\n    Parameters:\n        pixsize (float): Projected pixel size in kiloparsecs\n        shape (tuple): Size of grid on the field of view (Nx,Ny)\n        los_factor (int): Factor by which the z-axis is multiplied (Nz = los_factor * Nx) \n        x_off (int) : Offset along x, in pixels\n        y_off (int) : Offset along x, in pixels\n        z_off (int) : Offset along x, in pixels\n\n    \"\"\"\n\n\n    self.pixsize = pixsize\n\n    x_size, y_size = shape\n    z_size = int(shape[0]*los_factor)\n\n    self.x = jnp.linspace(self.pixsize * (-(x_size - 1)/2 + x_off), self.pixsize * ((x_size - 1)/2 + x_off), x_size) + pixsize/2\n    self.y = jnp.linspace(self.pixsize * (-(y_size - 1)/2 + y_off), self.pixsize * ((y_size - 1)/2 + y_off), y_size) + pixsize/2\n    self.z = jnp.linspace(self.pixsize * (-(z_size - 1)/2 + z_off), self.pixsize * ((z_size - 1)/2 + z_off), z_size)\n    self.X, self.Y, self.Z = jnp.meshgrid(self.x, self.y, self.z, indexing='ij', sparse=True)\n    self.y_i, self.x_i = jnp.indices(shape)\n    self.R = jnp.sqrt(self.X**2 + self.Y**2 + self.Z**2)\n    self.shape = (x_size, y_size, z_size)\n    self.volume = np.prod(self.shape)*pixsize**3\n</code></pre>"},{"location":"references/projection/","title":"Projection","text":""},{"location":"references/projection/#projection","title":"<code>projection</code>","text":""},{"location":"references/projection/#projection.VCubeProjection_v2","title":"<code>VCubeProjection_v2</code>","text":"<p>Projection of velocity cube with emission weighting in binned map</p> Source code in <code>src/projection.py</code> <pre><code>class VCubeProjection_v2 :\n    \"\"\"\n    Projection of velocity cube with emission weighting in binned map\n    \"\"\"\n    def __init__(self, binning, em_cube, PSF_kernel):\n        \"\"\"\n        Initialize\n\n        Parameters:\n            binning (jnp.Module): Binning\n            em_cube (jnp.array): 3D emissivity cube\n            PSF_kernel (jnp.array): PSF discretized on the pixel grid\n        \"\"\"\n\n        self.binning = binning\n        self.em = em_cube\n        self.PSF_kernel = PSF_kernel\n\n    def __call__(self,v):\n\n        \"\"\"\n        Uses counts to weight and project the velocity cube\n        into a centroid shift map and broadening map.\n        Uses a convolution with product in Fourier space.\n\n        Parameters:\n            v (jnp.array): Velocity cube\n\n        Returns:\n            v_map (jnp.array): Binned image of the emission weighted centroid shift\n            std_map (jnp.array): Binned image of the emission weighted broadening\n            binned_v_weighted (jnp.array): Vector of emission weighted centroid shift in each bin\n            binned_std_weighted (jnp.array): Vector of emission weighted broadening in each bin\n\n        \"\"\"\n\n        # This is a fully jaxified version\n\n        # Summing emission weighted speed in each pixel        \n        v_vec = jnp.sum(v*self.em, axis = -1)\n        std_vec = jnp.sum(v**2*self.em, axis = -1)\n        count_vec = jnp.sum(self.em, axis = -1)\n\n        # Convolution by PSF\n        v_vec_conv = my_convolution(v_vec, self.PSF_kernel)\n        std_vec_conv = my_convolution(std_vec, self.PSF_kernel)\n        count_vec_conv = my_convolution(count_vec, self.PSF_kernel)\n\n        # Extracting values within pixels from matrix\n        v_vec_conv_pix = v_vec_conv[self.binning.X_pixels,self.binning.Y_pixels]\n        std_vec_conv_pix = std_vec_conv[self.binning.X_pixels,self.binning.Y_pixels]\n        count_vec_conv_pix = count_vec_conv[self.binning.X_pixels,self.binning.Y_pixels]\n\n\n        # Indices of which bin each pixel goes in\n        bins_unique, inverse_indices = jnp.unique(self.binning.bin_num_pix, \n                                                  return_inverse=True, \n                                                  size = self.binning.nb_bins)\n\n        # Binned vectors\n        bin_v = jnp.zeros(len(bins_unique))\n        bin_counts = jnp.zeros(len(bins_unique))\n        bin_std = jnp.zeros(len(bins_unique))\n\n        # We add to each bin the weighted sum of all pixels belonging to it\n        bin_v = bin_v.at[inverse_indices].add(v_vec_conv_pix)\n        bin_counts = bin_counts.at[inverse_indices].add(count_vec_conv_pix)\n        bin_std = bin_std.at[inverse_indices].add(std_vec_conv_pix)\n\n\n        # Divide by weighing (i.e. summed emission)\n        binned_v_weighted = bin_v / bin_counts\n        binned_std_weighted = jnp.sqrt((bin_std/bin_counts - binned_v_weighted **2))\n\n        # Create maps\n        v_map = jnp.zeros(self.binning.shape)\n        v_map = v_map.at[self.binning.X_pixels, self.binning.Y_pixels].set(binned_v_weighted[inverse_indices])\n\n        std_map = jnp.zeros(self.binning.shape)\n        std_map = std_map.at[self.binning.X_pixels, self.binning.Y_pixels].set(binned_std_weighted[inverse_indices])\n\n        # Return weighted and binned values\n        return v_map, std_map, binned_v_weighted, binned_std_weighted\n</code></pre>"},{"location":"references/projection/#projection.VCubeProjection_v2.__call__","title":"<code>__call__(v)</code>","text":"<p>Uses counts to weight and project the velocity cube into a centroid shift map and broadening map. Uses a convolution with product in Fourier space.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array</code> <p>Velocity cube</p> required <p>Returns:</p> Name Type Description <code>v_map</code> <code>array</code> <p>Binned image of the emission weighted centroid shift</p> <code>std_map</code> <code>array</code> <p>Binned image of the emission weighted broadening</p> <code>binned_v_weighted</code> <code>array</code> <p>Vector of emission weighted centroid shift in each bin</p> <code>binned_std_weighted</code> <code>array</code> <p>Vector of emission weighted broadening in each bin</p> Source code in <code>src/projection.py</code> <pre><code>def __call__(self,v):\n\n    \"\"\"\n    Uses counts to weight and project the velocity cube\n    into a centroid shift map and broadening map.\n    Uses a convolution with product in Fourier space.\n\n    Parameters:\n        v (jnp.array): Velocity cube\n\n    Returns:\n        v_map (jnp.array): Binned image of the emission weighted centroid shift\n        std_map (jnp.array): Binned image of the emission weighted broadening\n        binned_v_weighted (jnp.array): Vector of emission weighted centroid shift in each bin\n        binned_std_weighted (jnp.array): Vector of emission weighted broadening in each bin\n\n    \"\"\"\n\n    # This is a fully jaxified version\n\n    # Summing emission weighted speed in each pixel        \n    v_vec = jnp.sum(v*self.em, axis = -1)\n    std_vec = jnp.sum(v**2*self.em, axis = -1)\n    count_vec = jnp.sum(self.em, axis = -1)\n\n    # Convolution by PSF\n    v_vec_conv = my_convolution(v_vec, self.PSF_kernel)\n    std_vec_conv = my_convolution(std_vec, self.PSF_kernel)\n    count_vec_conv = my_convolution(count_vec, self.PSF_kernel)\n\n    # Extracting values within pixels from matrix\n    v_vec_conv_pix = v_vec_conv[self.binning.X_pixels,self.binning.Y_pixels]\n    std_vec_conv_pix = std_vec_conv[self.binning.X_pixels,self.binning.Y_pixels]\n    count_vec_conv_pix = count_vec_conv[self.binning.X_pixels,self.binning.Y_pixels]\n\n\n    # Indices of which bin each pixel goes in\n    bins_unique, inverse_indices = jnp.unique(self.binning.bin_num_pix, \n                                              return_inverse=True, \n                                              size = self.binning.nb_bins)\n\n    # Binned vectors\n    bin_v = jnp.zeros(len(bins_unique))\n    bin_counts = jnp.zeros(len(bins_unique))\n    bin_std = jnp.zeros(len(bins_unique))\n\n    # We add to each bin the weighted sum of all pixels belonging to it\n    bin_v = bin_v.at[inverse_indices].add(v_vec_conv_pix)\n    bin_counts = bin_counts.at[inverse_indices].add(count_vec_conv_pix)\n    bin_std = bin_std.at[inverse_indices].add(std_vec_conv_pix)\n\n\n    # Divide by weighing (i.e. summed emission)\n    binned_v_weighted = bin_v / bin_counts\n    binned_std_weighted = jnp.sqrt((bin_std/bin_counts - binned_v_weighted **2))\n\n    # Create maps\n    v_map = jnp.zeros(self.binning.shape)\n    v_map = v_map.at[self.binning.X_pixels, self.binning.Y_pixels].set(binned_v_weighted[inverse_indices])\n\n    std_map = jnp.zeros(self.binning.shape)\n    std_map = std_map.at[self.binning.X_pixels, self.binning.Y_pixels].set(binned_std_weighted[inverse_indices])\n\n    # Return weighted and binned values\n    return v_map, std_map, binned_v_weighted, binned_std_weighted\n</code></pre>"},{"location":"references/projection/#projection.VCubeProjection_v2.__init__","title":"<code>__init__(binning, em_cube, PSF_kernel)</code>","text":"<p>Initialize</p> <p>Parameters:</p> Name Type Description Default <code>binning</code> <code>Module</code> <p>Binning</p> required <code>em_cube</code> <code>array</code> <p>3D emissivity cube</p> required <code>PSF_kernel</code> <code>array</code> <p>PSF discretized on the pixel grid</p> required Source code in <code>src/projection.py</code> <pre><code>def __init__(self, binning, em_cube, PSF_kernel):\n    \"\"\"\n    Initialize\n\n    Parameters:\n        binning (jnp.Module): Binning\n        em_cube (jnp.array): 3D emissivity cube\n        PSF_kernel (jnp.array): PSF discretized on the pixel grid\n    \"\"\"\n\n    self.binning = binning\n    self.em = em_cube\n    self.PSF_kernel = PSF_kernel\n</code></pre>"},{"location":"references/simulation/","title":"Simulation","text":""},{"location":"references/simulation/#simulation","title":"<code>simulation</code>","text":""},{"location":"references/simulation/#simulation.Simulation","title":"<code>Simulation</code>","text":"<p>               Bases: <code>Module</code></p> Source code in <code>src/simulation.py</code> <pre><code>class Simulation(hk.Module):\n\n    def __init__(self, \n                spatial_grid,\n                structure_function,\n                binning,\n                projection,\n                radial_bins_mes_errors,\n                censhift_offsets,\n                censhift_errors,\n                broad_offsets,\n                broad_errors,\n                ):\n        \"\"\"\n        Initialize simulation model\n\n        Parameters:\n            spatial_grid (hk.Module): 3D spatial grid\n            structure_function (hk.Module): Structure Function\n            binning (hk.Module): Binning\n            projection (hk.Module) : Projection\n            radial_bins_mes_errors (jnp.array): Bounds of the radial bins defininf the measurement error\n            censhift_offsets (jnp.array): Means of censhift measurement error\n            censhift_errors (jnp.array): stds of censhift measurement error\n            broad_offsets (jnp.array): Means of broadening measurement error\n            broad_errors (jnp.array): std of censhift measurement error\n        \"\"\"\n\n        super(Simulation, self).__init__()\n\n\n        # Initialize \n        self.fluctuation_generator = FluctuationCube(spatial_grid)\n        #self.pars = self.fluctuation_generator.init(rng_key())\n\n        # Binning\n        self.binning = binning\n\n        # Structure Function function\n        self.StructureFunction = structure_function\n\n        # Projection\n        self.projection = projection\n\n        # Half size of the grid\n        half_grid_size = spatial_grid.shape[0]/2\n\n        # Distances of bins to center of grid\n        rBar_bins = jnp.sqrt((binning.xBar_bins - half_grid_size)**2 + (binning.yBar_bins - half_grid_size)**2)\n\n        # Spread in centroid shift measurement error in each bin\n        self.offsets_v = censhift_offsets[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n        self.errors_v = censhift_errors[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n\n        # Spread in broadening measurement error in each bin\n        self.offsets_std = broad_offsets[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n        self.errors_std = broad_errors[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n\n    def __call__(self):\n        \"\"\"\n        Creates a realization of a GRF for the speed along the los\n        Projects the speed with em-weighting in binned maps\n        Adds measurement error\n        Returns the structure function\n\n        Returns:\n            dist (jn.array): Vector of separations at which the SF is computed\n            sf (jnp.array): SF of centroid shift\n            sf_std (jnp.array): SF of broadening\n            v_vec (jnp.array): Vector of centroid shifts\n            std_vec (jnp.array): Vector of broadenings\n        \"\"\"\n\n        key = hk.next_rng_key()\n\n        v_cube = self.fluctuation_generator()\n\n        _,_,v_vec, std_vec = self.projection(v_cube)\n\n        #Add measurement error on centroid shift\n        err_v = random.multivariate_normal(key = key,\n                                            mean = self.offsets_v, \n                                            cov = jnp.diag(self.errors_v**2))\n\n        v_vec += jnp.where(jnp.invert(jnp.isnan(err_v)), err_v, 0)\n        #v_vec = v_vec.at[jnp.invert(jnp.isnan(err_v))].add(err_v)\n\n\n        # Add measurement error on broadening \n        # with a Gamma distribution, so that for high broadening values, \n        # the errors are distributed normally around the expected vector\n        # and for low broadening values, the errors are always positive\n\n        mu = std_vec + self.offsets_std\n        a = mu**2 / self.errors_std**2\n        scale = self.errors_std**2 / mu\n        std_vec = random.gamma(key = rng_key(),a = a) * scale\n\n\n        #SF of velocity map\n        dist, sf = self.StructureFunction(v_vec , \n                                          self.binning.xBar_bins, \n                                          self.binning.yBar_bins)\n        dist, sf_std = self.StructureFunction(std_vec, \n                                              self.binning.xBar_bins, \n                                              self.binning.yBar_bins)\n\n        return dist, sf, sf_std, v_vec, std_vec\n</code></pre>"},{"location":"references/simulation/#simulation.Simulation.__call__","title":"<code>__call__()</code>","text":"<p>Creates a realization of a GRF for the speed along the los Projects the speed with em-weighting in binned maps Adds measurement error Returns the structure function</p> <p>Returns:</p> Name Type Description <code>dist</code> <code>array</code> <p>Vector of separations at which the SF is computed</p> <code>sf</code> <code>array</code> <p>SF of centroid shift</p> <code>sf_std</code> <code>array</code> <p>SF of broadening</p> <code>v_vec</code> <code>array</code> <p>Vector of centroid shifts</p> <code>std_vec</code> <code>array</code> <p>Vector of broadenings</p> Source code in <code>src/simulation.py</code> <pre><code>def __call__(self):\n    \"\"\"\n    Creates a realization of a GRF for the speed along the los\n    Projects the speed with em-weighting in binned maps\n    Adds measurement error\n    Returns the structure function\n\n    Returns:\n        dist (jn.array): Vector of separations at which the SF is computed\n        sf (jnp.array): SF of centroid shift\n        sf_std (jnp.array): SF of broadening\n        v_vec (jnp.array): Vector of centroid shifts\n        std_vec (jnp.array): Vector of broadenings\n    \"\"\"\n\n    key = hk.next_rng_key()\n\n    v_cube = self.fluctuation_generator()\n\n    _,_,v_vec, std_vec = self.projection(v_cube)\n\n    #Add measurement error on centroid shift\n    err_v = random.multivariate_normal(key = key,\n                                        mean = self.offsets_v, \n                                        cov = jnp.diag(self.errors_v**2))\n\n    v_vec += jnp.where(jnp.invert(jnp.isnan(err_v)), err_v, 0)\n    #v_vec = v_vec.at[jnp.invert(jnp.isnan(err_v))].add(err_v)\n\n\n    # Add measurement error on broadening \n    # with a Gamma distribution, so that for high broadening values, \n    # the errors are distributed normally around the expected vector\n    # and for low broadening values, the errors are always positive\n\n    mu = std_vec + self.offsets_std\n    a = mu**2 / self.errors_std**2\n    scale = self.errors_std**2 / mu\n    std_vec = random.gamma(key = rng_key(),a = a) * scale\n\n\n    #SF of velocity map\n    dist, sf = self.StructureFunction(v_vec , \n                                      self.binning.xBar_bins, \n                                      self.binning.yBar_bins)\n    dist, sf_std = self.StructureFunction(std_vec, \n                                          self.binning.xBar_bins, \n                                          self.binning.yBar_bins)\n\n    return dist, sf, sf_std, v_vec, std_vec\n</code></pre>"},{"location":"references/simulation/#simulation.Simulation.__init__","title":"<code>__init__(spatial_grid, structure_function, binning, projection, radial_bins_mes_errors, censhift_offsets, censhift_errors, broad_offsets, broad_errors)</code>","text":"<p>Initialize simulation model</p> <p>Parameters:</p> Name Type Description Default <code>spatial_grid</code> <code>Module</code> <p>3D spatial grid</p> required <code>structure_function</code> <code>Module</code> <p>Structure Function</p> required <code>binning</code> <code>Module</code> <p>Binning</p> required <code>projection</code> <code>hk.Module) </code> <p>Projection</p> required <code>radial_bins_mes_errors</code> <code>array</code> <p>Bounds of the radial bins defininf the measurement error</p> required <code>censhift_offsets</code> <code>array</code> <p>Means of censhift measurement error</p> required <code>censhift_errors</code> <code>array</code> <p>stds of censhift measurement error</p> required <code>broad_offsets</code> <code>array</code> <p>Means of broadening measurement error</p> required <code>broad_errors</code> <code>array</code> <p>std of censhift measurement error</p> required Source code in <code>src/simulation.py</code> <pre><code>def __init__(self, \n            spatial_grid,\n            structure_function,\n            binning,\n            projection,\n            radial_bins_mes_errors,\n            censhift_offsets,\n            censhift_errors,\n            broad_offsets,\n            broad_errors,\n            ):\n    \"\"\"\n    Initialize simulation model\n\n    Parameters:\n        spatial_grid (hk.Module): 3D spatial grid\n        structure_function (hk.Module): Structure Function\n        binning (hk.Module): Binning\n        projection (hk.Module) : Projection\n        radial_bins_mes_errors (jnp.array): Bounds of the radial bins defininf the measurement error\n        censhift_offsets (jnp.array): Means of censhift measurement error\n        censhift_errors (jnp.array): stds of censhift measurement error\n        broad_offsets (jnp.array): Means of broadening measurement error\n        broad_errors (jnp.array): std of censhift measurement error\n    \"\"\"\n\n    super(Simulation, self).__init__()\n\n\n    # Initialize \n    self.fluctuation_generator = FluctuationCube(spatial_grid)\n    #self.pars = self.fluctuation_generator.init(rng_key())\n\n    # Binning\n    self.binning = binning\n\n    # Structure Function function\n    self.StructureFunction = structure_function\n\n    # Projection\n    self.projection = projection\n\n    # Half size of the grid\n    half_grid_size = spatial_grid.shape[0]/2\n\n    # Distances of bins to center of grid\n    rBar_bins = jnp.sqrt((binning.xBar_bins - half_grid_size)**2 + (binning.yBar_bins - half_grid_size)**2)\n\n    # Spread in centroid shift measurement error in each bin\n    self.offsets_v = censhift_offsets[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n    self.errors_v = censhift_errors[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n\n    # Spread in broadening measurement error in each bin\n    self.offsets_std = broad_offsets[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n    self.errors_std = broad_errors[jnp.searchsorted(radial_bins_mes_errors, rBar_bins)-1]\n</code></pre>"},{"location":"references/structure_function/","title":"Structure Function","text":""},{"location":"references/structure_function/#structure_function","title":"<code>structure_function</code>","text":""},{"location":"references/structure_function/#structure_function.StructureFunction","title":"<code>StructureFunction</code>","text":"Source code in <code>src/structure_function.py</code> <pre><code>class StructureFunction:\n\n    def __init__(self, bins = np.geomspace(1,40,15)):\n        \"\"\"\n        Initialize\n        Parameters:\n            bins (jn.array): Edges of the radial bins in which to compute the SF\n        \"\"\"\n\n        self.bins = bins\n\n    def __call__(self, v_bin_vec, xbary, ybary):\n        \"\"\"\n        Computes the 2nd order structure function of an image with arbitrary binning.\n\n        Parameters:\n            v_bin_vec array (jn.array): Array of the count weighted velocity in each bin\n            xbary (jn.array): Array of the bin barycenters X coordinate\n            ybary (jn.array): Array of the bin barycenters Y coordinate\n            bins (jn.array): Array of the binning chosen for the SF\n\n        Returns:\n            bin_dists (jn.array): Separations of the SF\n            bin_means (jn.array): Values of the SF\n        \"\"\"\n\n        #Indexes of all possible combinations\n        idx = jnp.triu_indices(len(xbary), k = 1)\n\n        #Vector of all possible separations\n        sep_vec = jnp.hypot(xbary[idx[0]] - xbary[idx[1]],\n                               ybary[idx[0]] - ybary[idx[1]])\n\n        #Vector of (v_i - v_j)^2 \n        v_vec = (v_bin_vec[idx[0]] - v_bin_vec[idx[1]])**2\n\n        ### PREVIOUS VERSION\n        #Now compute binned statistics\n        #Average SF in each bin\n        #bin_means, bin_edges, binnumber = stats.binned_statistic(sep_vec, v_vec, 'mean', bins = self.bins)\n        #Average distance in each bin\n        #bin_dists, bin_edges, binnumber = stats.binned_statistic(sep_vec, sep_vec, 'mean', bins = self.bins)\n\n        ### JAX VERSION\n        hist_weighted, bin_edges = jnp.histogram(sep_vec, bins = self.bins, weights = v_vec)\n        hist_numbers, bin_edges = jnp.histogram(sep_vec, bins = self.bins)\n        hist_dists, _ = jnp.histogram(sep_vec, bins = self.bins, weights = sep_vec)\n\n        #Average SF in each bin\n        bin_means = hist_weighted/hist_numbers\n\n        #Average distance in each bin\n        hist_dists = hist_dists/hist_numbers\n\n\n        #Note : in principle, we shouldn't be taking the average distance in each bin, we should\n        #take the bin center, but that's for comparison purposes with Edo's code\n\n        return hist_dists, bin_means\n</code></pre>"},{"location":"references/structure_function/#structure_function.StructureFunction.__call__","title":"<code>__call__(v_bin_vec, xbary, ybary)</code>","text":"<p>Computes the 2<sup>nd</sup> order structure function of an image with arbitrary binning.</p> <p>Parameters:</p> Name Type Description Default <code>v_bin_vec</code> <code>array (jn.array</code> <p>Array of the count weighted velocity in each bin</p> required <code>xbary</code> <code>array</code> <p>Array of the bin barycenters X coordinate</p> required <code>ybary</code> <code>array</code> <p>Array of the bin barycenters Y coordinate</p> required <code>bins</code> <code>array</code> <p>Array of the binning chosen for the SF</p> required <p>Returns:</p> Name Type Description <code>bin_dists</code> <code>array</code> <p>Separations of the SF</p> <code>bin_means</code> <code>array</code> <p>Values of the SF</p> Source code in <code>src/structure_function.py</code> <pre><code>def __call__(self, v_bin_vec, xbary, ybary):\n    \"\"\"\n    Computes the 2nd order structure function of an image with arbitrary binning.\n\n    Parameters:\n        v_bin_vec array (jn.array): Array of the count weighted velocity in each bin\n        xbary (jn.array): Array of the bin barycenters X coordinate\n        ybary (jn.array): Array of the bin barycenters Y coordinate\n        bins (jn.array): Array of the binning chosen for the SF\n\n    Returns:\n        bin_dists (jn.array): Separations of the SF\n        bin_means (jn.array): Values of the SF\n    \"\"\"\n\n    #Indexes of all possible combinations\n    idx = jnp.triu_indices(len(xbary), k = 1)\n\n    #Vector of all possible separations\n    sep_vec = jnp.hypot(xbary[idx[0]] - xbary[idx[1]],\n                           ybary[idx[0]] - ybary[idx[1]])\n\n    #Vector of (v_i - v_j)^2 \n    v_vec = (v_bin_vec[idx[0]] - v_bin_vec[idx[1]])**2\n\n    ### PREVIOUS VERSION\n    #Now compute binned statistics\n    #Average SF in each bin\n    #bin_means, bin_edges, binnumber = stats.binned_statistic(sep_vec, v_vec, 'mean', bins = self.bins)\n    #Average distance in each bin\n    #bin_dists, bin_edges, binnumber = stats.binned_statistic(sep_vec, sep_vec, 'mean', bins = self.bins)\n\n    ### JAX VERSION\n    hist_weighted, bin_edges = jnp.histogram(sep_vec, bins = self.bins, weights = v_vec)\n    hist_numbers, bin_edges = jnp.histogram(sep_vec, bins = self.bins)\n    hist_dists, _ = jnp.histogram(sep_vec, bins = self.bins, weights = sep_vec)\n\n    #Average SF in each bin\n    bin_means = hist_weighted/hist_numbers\n\n    #Average distance in each bin\n    hist_dists = hist_dists/hist_numbers\n\n\n    #Note : in principle, we shouldn't be taking the average distance in each bin, we should\n    #take the bin center, but that's for comparison purposes with Edo's code\n\n    return hist_dists, bin_means\n</code></pre>"},{"location":"references/structure_function/#structure_function.StructureFunction.__init__","title":"<code>__init__(bins=np.geomspace(1, 40, 15))</code>","text":"<p>Initialize Parameters:     bins (jn.array): Edges of the radial bins in which to compute the SF</p> Source code in <code>src/structure_function.py</code> <pre><code>def __init__(self, bins = np.geomspace(1,40,15)):\n    \"\"\"\n    Initialize\n    Parameters:\n        bins (jn.array): Edges of the radial bins in which to compute the SF\n    \"\"\"\n\n    self.bins = bins\n</code></pre>"},{"location":"references/temperature/","title":"Temperature","text":""},{"location":"references/temperature/#temperature","title":"<code>temperature</code>","text":""},{"location":"references/temperature/#temperature.GhirardiniModel","title":"<code>GhirardiniModel</code>","text":"<p>               Bases: <code>Module</code></p> <p>Universal temperature profile as defined in Ghirardini 2018+ in the X-COP cluster sample</p> Source code in <code>src/temperature.py</code> <pre><code>class GhirardiniModel(hk.Module):\n    \"\"\"\n    Universal temperature profile as defined in Ghirardini 2018+ in the X-COP cluster sample\n    \"\"\"\n\n    def __init__(self):\n        super(GhirardiniModel, self).__init__()\n        self.cosmo = LambdaCDM(H0 = 70, Om0 = 0.3, Ode0= 0.7)\n\n\n    def __call__(self, r, z = 0.1):\n        r\"\"\"Compute the temperature function for a given radius.\n\n        $$\\dfrac{T(x)}{T_{500}} = T_0 \\dfrac{\\frac{T_\\mathrm{min}}{T_0} + (\\frac{x}{r_\\mathrm{cool}})^{a_\\mathrm{cool}}}{1 + (\\frac{x}{r_\\mathrm{cool}})^{a_\\mathrm{cool}}} \\frac{1}{(1 + (\\frac{x}{r_t})^2)^{\\frac{c}{2}}}$$\n\n        Parameters:\n            r (jnp.array): Radius at which to compute the temperature, in kpc\n            z (float): Redshift of cluster\n        Returns:\n            (jnp.array): Temperature function evaluated at the given radius in keV\n        \"\"\"\n\n\n        M500 = 0.7 #(x10^15 Msun)\n        Ez   = self.cosmo.efunc(z)\n        h_70 = 0.7\n\n        T500 = 8.85 * (M500*h_70)**(2./3.) * Ez**(2./3.)\n        T0 = 1.09\n        rcool = jnp.exp(-4.4)\n        rt = 0.45\n        TmT0 = 0.66\n        acool = 1.33\n        c2 = 0.3\n\n        R500 = 1309. #[kpc]\n        x = r/R500\n\n        term1 = (TmT0 + (x / rcool) ** acool)\n        term2 = (1 + (x / rcool) ** acool) * (1 + (x / rt) ** 2) ** c2\n\n        T = T500 * T0 * term1 / term2\n\n        #Clip the values to the [1-7] keV range (otherwise the T-Z interpolation does not work.)\n        return T #jnp.clip(T, 1., 7.)\n</code></pre>"},{"location":"references/temperature/#temperature.GhirardiniModel.__call__","title":"<code>__call__(r, z=0.1)</code>","text":"<p>Compute the temperature function for a given radius.</p> \\[\\dfrac{T(x)}{T_{500}} = T_0 \\dfrac{\\frac{T_\\mathrm{min}}{T_0} + (\\frac{x}{r_\\mathrm{cool}})^{a_\\mathrm{cool}}}{1 + (\\frac{x}{r_\\mathrm{cool}})^{a_\\mathrm{cool}}} \\frac{1}{(1 + (\\frac{x}{r_t})^2)^{\\frac{c}{2}}}\\] <p>Parameters:</p> Name Type Description Default <code>r</code> <code>array</code> <p>Radius at which to compute the temperature, in kpc</p> required <code>z</code> <code>float</code> <p>Redshift of cluster</p> <code>0.1</code> <p>Returns:     (jnp.array): Temperature function evaluated at the given radius in keV</p> Source code in <code>src/temperature.py</code> <pre><code>def __call__(self, r, z = 0.1):\n    r\"\"\"Compute the temperature function for a given radius.\n\n    $$\\dfrac{T(x)}{T_{500}} = T_0 \\dfrac{\\frac{T_\\mathrm{min}}{T_0} + (\\frac{x}{r_\\mathrm{cool}})^{a_\\mathrm{cool}}}{1 + (\\frac{x}{r_\\mathrm{cool}})^{a_\\mathrm{cool}}} \\frac{1}{(1 + (\\frac{x}{r_t})^2)^{\\frac{c}{2}}}$$\n\n    Parameters:\n        r (jnp.array): Radius at which to compute the temperature, in kpc\n        z (float): Redshift of cluster\n    Returns:\n        (jnp.array): Temperature function evaluated at the given radius in keV\n    \"\"\"\n\n\n    M500 = 0.7 #(x10^15 Msun)\n    Ez   = self.cosmo.efunc(z)\n    h_70 = 0.7\n\n    T500 = 8.85 * (M500*h_70)**(2./3.) * Ez**(2./3.)\n    T0 = 1.09\n    rcool = jnp.exp(-4.4)\n    rt = 0.45\n    TmT0 = 0.66\n    acool = 1.33\n    c2 = 0.3\n\n    R500 = 1309. #[kpc]\n    x = r/R500\n\n    term1 = (TmT0 + (x / rcool) ** acool)\n    term2 = (1 + (x / rcool) ** acool) * (1 + (x / rt) ** 2) ** c2\n\n    T = T500 * T0 * term1 / term2\n\n    #Clip the values to the [1-7] keV range (otherwise the T-Z interpolation does not work.)\n    return T #jnp.clip(T, 1., 7.)\n</code></pre>"},{"location":"references/turbulence/","title":"Turbulence","text":""},{"location":"references/turbulence/#turbulence","title":"<code>turbulence</code>","text":""},{"location":"references/turbulence/#turbulence.KolmogorovPowerSpectrum","title":"<code>KolmogorovPowerSpectrum</code>","text":"<p>               Bases: <code>Module</code></p> <p>Kolmogorov power spectrum</p> Source code in <code>src/turbulence.py</code> <pre><code>class KolmogorovPowerSpectrum(hk.Module):\n    \"\"\"\n    Kolmogorov power spectrum\n    \"\"\"\n\n    def __init__(self):\n        super(KolmogorovPowerSpectrum, self).__init__()\n\n    def __call__(self, k):\n        r\"\"\"Kolmogorov power spectrum\n\n        $$\\mathcal{P}_{3D}(k)= \\sigma^2 \\frac{e^{-\\left(k/k_{\\text{inj}}\\right)^2} e^{-\\left(k_{\\text{dis}}/k\\right)^2} k^{-\\alpha} }{\\int 4\\pi k^2  \\, e^{-\\left(k/k_{\\text{inj}}\\right)^2} e^{-\\left(k_{\\text{dis}}/k\\right)^2} k^{-\\alpha} \\text{d} k}$$\n\n        \"\"\"\n\n        sigma = hk.get_parameter(\"sigma\", [], init=Constant(250)) #km/s\n        log_inj = hk.get_parameter(\"log_inj\", [], init=Constant(jnp.log10(300))) #kpc\n        log_dis = jnp.log10(10) #kpc\n        alpha = hk.get_parameter(\"alpha\", [], init=Constant(11/3))\n\n        k_inj = 10 ** (-log_inj)\n        k_dis = 10 ** (-log_dis)\n\n        #sigma = 10**log_sigma\n\n        k_int = jnp.geomspace(k_inj/20, k_dis*20, 1000)\n        norm = integrate.trapezoid(4*jnp.pi*k_int**3*jnp.exp(-(k_inj / k_int) ** 2) * jnp.exp(-(k_int/ k_dis) ** 2) * (k_int) ** (-alpha), x=jnp.log(k_int))\n        res = jnp.where(k &gt; 0, jnp.exp(-(k_inj / k) ** 2) * jnp.exp(-(k/ k_dis) ** 2) * (k) ** (-alpha), 0.)\n\n        return sigma**2 * res / norm\n</code></pre>"},{"location":"references/turbulence/#turbulence.KolmogorovPowerSpectrum.__call__","title":"<code>__call__(k)</code>","text":"<p>Kolmogorov power spectrum</p> \\[\\mathcal{P}_{3D}(k)= \\sigma^2 \\frac{e^{-\\left(k/k_{\\text{inj}}\\right)^2} e^{-\\left(k_{\\text{dis}}/k\\right)^2} k^{-\\alpha} }{\\int 4\\pi k^2  \\, e^{-\\left(k/k_{\\text{inj}}\\right)^2} e^{-\\left(k_{\\text{dis}}/k\\right)^2} k^{-\\alpha} \\text{d} k}\\] Source code in <code>src/turbulence.py</code> <pre><code>def __call__(self, k):\n    r\"\"\"Kolmogorov power spectrum\n\n    $$\\mathcal{P}_{3D}(k)= \\sigma^2 \\frac{e^{-\\left(k/k_{\\text{inj}}\\right)^2} e^{-\\left(k_{\\text{dis}}/k\\right)^2} k^{-\\alpha} }{\\int 4\\pi k^2  \\, e^{-\\left(k/k_{\\text{inj}}\\right)^2} e^{-\\left(k_{\\text{dis}}/k\\right)^2} k^{-\\alpha} \\text{d} k}$$\n\n    \"\"\"\n\n    sigma = hk.get_parameter(\"sigma\", [], init=Constant(250)) #km/s\n    log_inj = hk.get_parameter(\"log_inj\", [], init=Constant(jnp.log10(300))) #kpc\n    log_dis = jnp.log10(10) #kpc\n    alpha = hk.get_parameter(\"alpha\", [], init=Constant(11/3))\n\n    k_inj = 10 ** (-log_inj)\n    k_dis = 10 ** (-log_dis)\n\n    #sigma = 10**log_sigma\n\n    k_int = jnp.geomspace(k_inj/20, k_dis*20, 1000)\n    norm = integrate.trapezoid(4*jnp.pi*k_int**3*jnp.exp(-(k_inj / k_int) ** 2) * jnp.exp(-(k_int/ k_dis) ** 2) * (k_int) ** (-alpha), x=jnp.log(k_int))\n    res = jnp.where(k &gt; 0, jnp.exp(-(k_inj / k) ** 2) * jnp.exp(-(k/ k_dis) ** 2) * (k) ** (-alpha), 0.)\n\n    return sigma**2 * res / norm\n</code></pre>"}]}